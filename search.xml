<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习入门笔记（四）-CNN]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-CNN%2F</url>
    <content type="text"><![CDATA[CNN,全称：Convolutional Neural Network，中文名称：卷积神经网络 CNN实现验证码识别：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import numpy as npimport tensorflow as tffrom utils import read_datatrain_dir = "data"test_dir = "test_data"# train标志着是训练还是测试train = False# 模型最后的保存路径model_path = "model/image_model"# 这是样本的标签种类char_to_digit = ["零","壹","贰","叁","肆","伍","陆","柒","捌","玖","拾","一","二","三","四","五","六","七","八","九","加","减","乘","除"]fpaths, datas, labels = read_data(train_dir)test_fpath, test_datas, test_labels = read_data(test_dir)data_len = datas.shape[0]# n_classes 表示有多少类图片n_classes = len(set(labels))# 定义占位符，存放图片和对应的标签 图片数据大小为30*26*1，存放的数据为像素值归一化后的值X = tf.placeholder(tf.float32, [None, 30, 26, 1])Y = tf.placeholder(tf.int32, [None])# drop为dropout参数，为一个百分比，表示反向传播时，选取一部分参数不进行更新，减少过拟合，训练时为0.25，测试时为0drop = tf.placeholder(tf.float32)# 定义第一层卷积，20个卷积核，核大小为1*1，即全卷积，relu激活conv1 = tf.layers.conv2d(X, 20, 1, activation=tf.nn.relu)# 定义第二层卷积, 20个卷积核, 核大小为1*1，Relu激活conv2 = tf.layers.conv2d(conv1, 20, 1, activation=tf.nn.relu)# 将三维向量拉伸为一维flat = tf.layers.flatten(conv2)# 全连接，将输入转换成一个1000维向量，还是采用relu激活fc = tf.layers.dense(flat, 1000, activation=tf.nn.relu)# 计算dropoutdrop_func = tf.layers.dropout(fc, drop)# 这里再次全连阶，压缩到与分类维度对应的向量logits = tf.layers.dense(drop_func, n_classes)# tf.argmax返回的是指定维度上最大值的索引值index# 这里pred_labels可以用来标志最后的预测结果pred_labels = tf.argmax(logits, 1)# 损失函数采用交叉熵，loss = tf.nn.softmax_cross_entropy_with_logits( labels=tf.one_hot(Y, n_classes), logits=logits)# softmax_cross_entropy_with_logits返回的不是一个具体的值，而是一个向量，这里需要求平均值m_loss = tf.reduce_mean(loss)# 定义优化器，学习率为0.001optimizer = tf.train.AdamOptimizer(learning_rate=1e-3).minimize(m_loss)# saver用来保存训练的模型saver = tf.train.Saver()if __name__ == '__main__': with tf.Session() as sess: if train: print("train") # init sess.run(tf.global_variables_initializer()) # 迭代50次 for i in range(100): _, loss_v = sess.run([optimizer, m_loss], feed_dict=&#123; X: datas, Y: labels, drop: 0.25, &#125; ) if i % 10 == 0: print("step:&#123;&#125;--&gt;loss:&#123;&#125;".format(i, loss_v)) saver.save(sess, model_path) print("Done!，save as :&#123;&#125;".format(model_path)) else: # 测试 print("test") saver.restore(sess, model_path) print("recover from:&#123;&#125;".format(model_path)) # label_map是模型输出值与实际分类标签的分类 label_map = &#123;k: v for k, v in enumerate(char_to_digit)&#125; pred_val = sess.run(pred_labels, feed_dict=&#123; X: test_datas, Y: test_labels, drop: 0 &#125;) # 真实label与模型预测label err_count = 0 for fpath, real_label, predicted_label in zip(test_fpath, test_labels, pred_val): # 将label id转换为label名 real_label_name = label_map[real_label] pred_name = label_map[predicted_label] if real_label_name != pred_name: err_count += 1 print(1 - err_count/len(test_datas)) 这里迭代100次只是我挑选的比较快的迭代到局部最低点的次数，后续有运算条件再加大迭代次数，找一个更低的点卷积层采用核为1的全卷积（又称FCN），可以提取到像素级别的信息，为了更多的提取图片信息，我没有使用池化层 测试结果：123testrecover from:model/image_model0.6774193548387097 这里和之前的KMeans，KNN一样的样本数量，训练集760张样本，测试集68%的正确率ok，CNN实践暂时告一段落，等后续有了更多样本再做优化]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法的python实现]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常见排序算法的python实现以下代码实现的排序算法有：选择排序，冒泡排序，插入排序，希尔排序，归并排序，快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# -*- coding:utf-8 -*-li = [23, 12, 43, 45, 54, 514, 412, 543, 123, 534, 675, 1232]def select_sort(li): # 选择排序 for i in range(len(li)): for j in range(i, len(li)): if li[i] &gt; li[j]: li[i], li[j] = li[j], li[i] return liprint(select_sort(li))def bubble_sort(li): # 冒泡排序 for i in range(len(li)): for j in range(1, len(li) - i): if li[j] &lt; li[j - 1]: li[j], li[j - 1] = li[j - 1], li[j] return liprint(bubble_sort(li))def insert_sort(li): # 插入排序 for i in range(1, len(li)): key = li[i] j = i - 1 while j &gt;= 0: if key &lt; li[j]: li[j + 1] = li[j] li[j] = key j -= 1 return liprint(insert_sort(li))def shell_sort(li): # 希尔排序 gap = len(li) % 2 while gap &gt; 0: for i in range(gap, len(li)): if li[i] &lt; li[i - gap]: li[i - gap], li[i] = li[i], li[i - gap] return liprint(shell_sort(li))def merge_sort(l1, l2): # 归并排序 l3 = [] j = 0 for i in range(len(l1)): while j &lt; len(l2) and l1[i] &gt; l2[j]: l3.append(l2[j]) j += 1 l3.append(l1[i]) if j &lt; len(l2) - 1: while j &lt; len(l2): l3.append(l2[j]) j += 1 return l3list1 = [1, 3, 5, 7, 9]list2 = [2, 4, 6, 8, 10, 11, 12, 13, 14]print(merge_sort(list1, list2))def quick_sort(li, start, end): # 快速排序 if start &lt; end: index = kp(li, start, end) quick_sort(li, index +1, end) quick_sort(li, start, index) return lidef kp(li, start, end): # 快速排序用来排序的函数 base = li[start] while start &lt; end: while base &lt;= li[end] and start &lt; end: end -= 1 while start &lt; end and base &gt; li[end]: li[start], li[end] = li[end], li[start] start += 1 return startprint(quick_sort(li, 0, len(li) - 1))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习入门笔记（三）-KNN]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-KNN%2F</url>
    <content type="text"><![CDATA[上一篇用KMeans实现的验证码识别准确率不太高，不想继续标注数据的我尝试了一下KNN算法，发现同样的数据量，KNN的准确率有显著提升12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-import numpy as npimport tensorflow as tffrom tensorflow.contrib.factorization import KMeans# deal_data是我本地的样本处理脚本，这里就不放上来了from deal_data import train_X, train_Y, test_X, test_Y# train_X：训练集图片像素矩阵，【760*780】 760张图片# train_Y： 训练集图片的标签，onehot格式【760*24】# test_X，test_Y 为测试数据，格式和训练集一致# 定义占位符TRAIN_X = tf.placeholder("float", [None, 780])TEST_X = tf.placeholder("float", [780])# 计算L1正则距离# tf.abs(tf.add(train_X, tf.negative(test_X)))的计算结果是一个（760*780）矩阵，表示测试图片与每一张训练集图片的像素差值# distance的结果为一个（760，）向量，表示测试图片与每一张训练集图片像素总差值distance = tf.reduce_sum(tf.abs(tf.add(TRAIN_X, tf.negative(TEST_X))), reduction_indices=1)# 预测结果pred取距离最小的那个训练集图片的索引pred = tf.arg_min(distance, 0)accuracy = 0.# 初始化变量init = tf.initialize_all_variables()# 开始迭代if __name__ == '__main__': with tf.Session() as sess: sess.run(init) # 遍历测试集 for i in range(len(test_X)): # 获取最近邻 nearest_idx = sess.run(pred, feed_dict=&#123;TRAIN_X: train_X, TEST_X: test_X[i, :]&#125;) # 如果最近邻标签索引和真是标签索引一致，则预测准确 if np.argmax(train_Y[nearest_idx]) == np.argmax(test_Y[i]): accuracy += 1. / len(test_X) print("Done!") print("Accuracy:", accuracy) 12Done!Accuracy: 0.8709677419354833 0.87！！,仅760张训练样本就能这么高的准确率，哈哈]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>KNN</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习入门笔记（二）-KMeans]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-KMeans%2F</url>
    <content type="text"><![CDATA[最近学习了KMeans算法，想着把KMeans用到验证码识别中试试效果验证码大概长这样：这是一个算术验证码，里面的大概包含了一到九的简体和繁体字，以及加减乘除四个字，共计24个类别训练代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding:utf-8 -*-import numpy as npimport tensorflow as tffrom tensorflow.contrib.factorization import KMeans# deal_data是我本地的样本处理脚本，这里就不放上来了from deal_data import train_X, train_Y, test_X, test_Ytrain_X = train_X / 255train_Y = train_Y / 255test_X = test_X / 255test_Y = test_Y / 255# 这里X是一个？*780的数组，对应？张图片。每张图片大小为30*26，拉成一维后：780# Y 是每张图片对应的分类，值为onehot形式，维度为（?,24）# 参数设置num_steps = 1000 # 迭代次数k = 24 # 聚类中心数目num_classes = 24 # 数据标签数目# 定义占位符X = tf.placeholder(dtype=tf.float32, shape=[None, 780])Y = tf.placeholder(dtype=tf.float32, shape=[None, num_classes])# kmeans初始化# 使用余弦相似度，cosinekmeans = KMeans(inputs=X, num_clusters=k, distance_metric="cosine", use_mini_batch=True)all_scores, cluster_idx, _, _, init_op, training_op = kmeans.training_graph()# all_scores： 所有的输入与对应对的中心的相似度，维度为（?，24）# cluster_idx：每个图片对应的聚类中心点,# init_op：kmeans聚类中心的初始化操作节点# training_op：kmeans的训练迭代节点cluster_index = cluster_idx[0] # cluster_idx是一个元组，第一个元素才是每个图片对应的聚类中心点索引avg_distance = tf.reduce_mean(all_scores) # 计算相似度的平均值init_param = tf.global_variables_initializer() # tensorflow全部变量的初始化操作节点with tf.Session() as sess: # 运行tensorflow变量初始化 sess.run(init_param) # 运行kmeans初始化 sess.run(init_op, feed_dict=&#123;X: train_X&#125;) # 开始迭代 for i in range(1, num_steps+1): _, distance, idx = sess.run([training_op, avg_distance, cluster_index], feed_dict=&#123;X: train_X&#125;) if i % 10 == 0 or i == 1: print("Step: %d, distance=%f" % (i, distance)) counts = np.zeros(shape=(k, num_classes)) for i in range(len(idx)): # counts 记录的时每一个聚类中心下的图片分类统计， counts[idx[i]] += train_Y[i] # 维度：（len(idx)，24） # clustags_to_imtags记录的是每一个聚类中心下分布最多的图片分类， clustags_to_imtags = [np.argmax(c) for c in counts] # 维度：（len(idx)） # 将clustags_to_imtags转化成张量 clustags_to_imtags = tf.convert_to_tensor(clustags_to_imtags) # ------------------------------------------------ # 下面是验证时的运算图 # pred_label是将每一个图片的聚类中心的分布最多的那个图片分类作为预测的结果 pred_label = tf.nn.embedding_lookup(clustags_to_imtags, cluster_index) # 维度：（len(idx)） # 计算正确率 equal_prediction = tf.equal(pred_label, tf.cast(tf.argmax(Y, 1), tf.int32)) accuracy_op = tf.reduce_mean(tf.cast(equal_prediction, tf.float32)) # tf.cast(equal_prediction, tf.float32) 可以将bool值转化为1.0或者0.0,这样计算平均值接可以得到正确率 # 测试模型 test_x, test_y = test_X, test_Y print("验证集准确率:", sess.run(accuracy_op, feed_dict=&#123;X: test_x, Y: test_y&#125;)) 训练结果：123456789101112131415161718Step: 1, distance=0.174805Step: 10, distance=0.118283Step: 20, distance=0.118261Step: 30, distance=0.118271Step: 40, distance=0.118258Step: 50, distance=0.118246Step: 60, distance=0.118242...Step: 920, distance=0.118216Step: 930, distance=0.118216Step: 940, distance=0.118216Step: 950, distance=0.118216Step: 960, distance=0.118216Step: 970, distance=0.118216Step: 980, distance=0.118216Step: 990, distance=0.118216Step: 1000, distance=0.118216验证集准确率: 0.38709676 这里由于训练样本数量有限，全手动打标签，只标注了760张，所以正确率有点低，验证集只有大概0.387的正确率，等后面有时间再考虑增加数据量]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>KMeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习入门笔记（一）-多项式回归]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[一、生成数据，生成100个点，x是从-3到3之间均匀分布的，y是x的正弦函数值加上-0.5～0.5之间的一个随机值得到的结果12345678910%matplotlib inlineimport numpy as npimport tensorflow as tfimport matplotlib.pyplot as pltplt.rcParams["figure.figsize"] = (14,8)n_insp = 100x_set = np.linspace(-3, 3, n_insp)y_set = np.sin(x_set) + np.random.uniform(-0.5, 0.5, n_insp)plt.scatter(x_set, y_set) &lt;matplotlib.collections.PathCollection at 0x7f4022ac3390&gt; 二、定义参数输入参数的占位符12X = tf.placeholder(tf.float32, name = "X")Y = tf.placeholder(tf.float32, name= "Y") 三、定义运算图，假定特征有x,x^2,x^3,三项，则整个函数的计算为 y=wx + W1x^2 + w2*x^3 + b1234567w = tf.Variable(tf.random_normal([1]), name = "weight")w1= tf.Variable(tf.random_normal([1]), name = "weight_1")w2 = tf.Variable(tf.random_normal([1]), name = "weight_2")b = tf.Variable(tf.random_normal([1]), name= "bias")Y_predict = tf.add(tf.multiply(X, w), tf.multiply(w1, tf.pow(X,2)))Y_predict = tf.add(Y_predict, tf.multiply(w2, tf.pow(X,3)))Y_predict = tf.add(Y_predict, b) 四、定义损失函数和初始化optimizer,这里损失函数是计算y与预测值的方差均值1x_set.shape (100,) 1234loss = tf.reduce_sum(tf.pow(Y_predict - Y, 2)) / x_set.shape[0]# 定义学习率为 0.01learning_rate = 0.01optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss) 五、训练迭代123456789101112131415161718with tf.Session() as sess: # 初始化所有变量 sess.run(tf.global_variables_initializer()) # 定义tensorboard的log保存路径 writer = tf.summary.FileWriter("./graphs/polynomial_regulation", sess.graph) for i in range(1000): # 每一对数据进行一次迭代，遍历完数据集为一轮，共训练1000轮 sum_loss = 0 for x, y in zip(x_set, y_set): _, l = sess.run([optimizer, loss],feed_dict = &#123;X:x,Y:y&#125;) sum_loss += l if i%20 == 0: # 每二十轮打印一次当前准确率 print('Epoch &#123;0&#125;: &#123;1&#125;'.format(i, sum_loss/x_set.shape[0])) writer.close() # 取出最后的权重和偏移值 w, w1, w2, b = sess.run([w,w1,w2,b]) Epoch 0: 0.011287849849201415 Epoch 20: 0.002904312098070534 Epoch 40: 0.0022930659861960124 Epoch 60: 0.001861640907111166 Epoch 80: 0.0015570845219596663 Epoch 100: 0.0013421906849065124 Epoch 120: 0.0011906639028636335 Epoch 140: 0.0010839080285924751 Epoch 160: 0.0010087724971023703 Epoch 180: 0.0009559617677211918 Epoch 200: 0.0009189029343284005 Epoch 220: 0.0008929493658629184 Epoch 240: 0.0008748186269485813 Epoch 260: 0.0008621914480389414 Epoch 280: 0.0008534308153672754 Epoch 300: 0.0008473811643942852 Epoch 320: 0.0008432286334247863 Epoch 340: 0.0008403999191202516 Epoch 360: 0.0008384917434211502 Epoch 380: 0.0008372206560037965 Epoch 400: 0.00083638845353045 Epoch 420: 0.0008358570021426814 Epoch 440: 0.000835529392748171 Epoch 460: 0.0008353382271738141 Epoch 480: 0.0008352376613193435 Epoch 500: 0.0008351957923265729 Epoch 520: 0.0008351906345031778 Epoch 540: 0.0008352075220511918 Epoch 560: 0.0008352370859906216 Epoch 580: 0.0008352726358773677 Epoch 600: 0.0008353100529581625 Epoch 620: 0.0008353470957054076 Epoch 640: 0.0008353820821457792 Epoch 660: 0.0008354142016842925 Epoch 680: 0.0008354429479974713 Epoch 700: 0.0008354686113952425 Epoch 720: 0.0008354910716359676 Epoch 740: 0.000835510656680416 Epoch 760: 0.0008355276462786598 Epoch 780: 0.0008355419888481741 Epoch 800: 0.000835554459651977 Epoch 820: 0.0008355653869491241 Epoch 840: 0.0008355743816347427 Epoch 860: 0.0008355819873166936 Epoch 880: 0.0008355887906360771 Epoch 900: 0.000835594305444296 Epoch 920: 0.0008355990350996834 Epoch 940: 0.0008356031159648758 Epoch 960: 0.0008356063359790334 Epoch 980: 0.0008356092827835581 1234print("w:"+str(w[0]))print("w1:"+str(w1[0]))print("w2:"+str(w2[0]))print("b:"+str(b[0])) w:0.84994864 w1:0.018252745 w2:-0.09445592 b:-0.07383199 六、结果展示1234plt.plot(x_set, y_set, 'bo', label='Real data')plt.plot(x_set, x_set*w+ np.power(x_set,2)*w1 + np.power(x_set,3)*w2 + b, 'r', label='Predicted data')plt.legend()plt.show()]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>多项式回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-学习笔记（三）-过滤器]]></title>
    <url>%2F2019%2F03%2F06%2Fspring-boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;过滤器有两种配置方式，一种是通过注解来完成，一种是通过自定义配置类来设置这里假设的场景是，定义一个过滤器，过滤所有请求，如果参数中没有username信息则重定向到login_page登录页面，如果带有username则放行 注解-WebFilter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.demo.myFilter;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @author fengxi * @date 2019-03-06 10:47 */@WebFilter(value = "/*") // WebFilter注解告诉spring这是一个过滤器@Component // Component注解表示这是一个组件，需要创建出一个实例来public class firstFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("init，在服务启动的时候被调用"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String path = req.getRequestURI(); HttpSession session = req.getSession(); if (req.getParameter("username") != null)&#123; // 放行 chain.doFilter(request, response); &#125;else &#123; System.out.println(path); if (path.equals("/login_page")) &#123; // 如果本身访问的是登录页面，直接放行 chain.doFilter(request, response); &#125; else &#123; // 没有username，访问非登录页面，重定向到登录页面 HttpServletResponse resp = (HttpServletResponse) response; resp.sendRedirect("login_page"); &#125; &#125; &#125; @Override public void destroy() &#123; System.out.println("destroy，在停止服务程序的时候会调用"); &#125;&#125; 代码配置1。 在fitler实现类不使用注解123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.demo.myFilter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @author fengxi * @date 2019-03-06 15:31 */public class secondFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("init"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String path = req.getRequestURI(); HttpSession session = req.getSession(); if (req.getParameter("username") != null)&#123; chain.doFilter(request, response); &#125;else &#123; System.out.println(path); if (path.equals("/login_page")) &#123; chain.doFilter(request, response); &#125; else &#123; HttpServletResponse resp = (HttpServletResponse) response; resp.sendRedirect("login_page"); &#125; &#125; &#125; @Override public void destroy() &#123; System.out.println("destroy"); &#125;&#125; 2。 使用configuration注解定义过滤器1234567891011121314151617181920212223242526272829package com.example.demo.config;import com.example.demo.myFilter.secondFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author fengxi * @date 2019-03-06 15:30 */@Configurationpublic class myConfig &#123; @Bean("bean1") public FilterRegistrationBean registerFilter1()&#123; // 创建过滤器注册bean对象 FilterRegistrationBean bean1 = new FilterRegistrationBean(); // 设置要配置的过滤器对象 bean1.setFilter(new secondFilter()); // 添加该过滤器要过滤的url规则 bean1.addUrlPatterns("/*"); // 设置过滤器执行的优先级，数字小的先执行 bean1.setOrder(1); return bean1; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 学习笔记（二）-会话]]></title>
    <url>%2F2019%2F03%2F05%2Fspring-boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BC%9A%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;两个http请求之间本身是没有关联的，有些时候需要用cookie 和session来记录一些之前的请求的信息cookie 直接将信息保存在客户端，每次请求将之前在浏览器保存的cookie 带上，这种方式减轻了服务器压力，但是同时他存储的信息直接暴露在客户端也带了一些安全问题，浏览器对单域名下保存的cookie个数和数据大小也有限制session将数据保存在服务器，客户端只需用cookie保存一个sessionid，这样就解决了一些安全问题，同时只要服务器性能足够，session可以存放数据的大小是无限制的,但会增加服务器压力1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.demo.controller; import com.example.demo.user.User; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession;@RestControllerpublic class firstController &#123; @RequestMapping("hello") public String Hello(User user, HttpServletRequest request, HttpServletResponse response)&#123; // 创建cookie对象 Cookie cookie = new Cookie("username", user.getUsername()); // 设置cookie有效期，单位：秒 cookie.setMaxAge(60*60*24*7); // 设置跨域携带cookie cookie.setDomain("www.superstorm.site"); // 给响应设置cookie response.addCookie(cookie); // 从request获取session对象 HttpSession session = request.getSession(); // 获取session id String id = session.getId(); // 添加session内容 session.setAttribute("age", 18); // 移除字段// session.removeAttribute("age"); // 销毁session内存，session分配的内存如果没有手动销毁，会有框架自动进行回收// session.invalidate();// session.setAttribute("name", "storm"); // session 持久化 Cookie cookie1 = new Cookie("JSSESSIONID", session.getId()); cookie1.setMaxAge(60 * 60 * 24 * 7); response.addCookie(cookie1); return "Hello World!" + user.getUsername(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot 学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F01%2Fspring-boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用IntelliJ IDEA一键初始化一个web应用在打开新建项目后选择spring initializr,然后next在type选择gradle project，language选择java，然后next勾选web，随后next输入项目名称和项目路径就可以finish啦，这里我使用默认的demo名称 下面就进入spring boot的世界啦， 在DemoApplication文件中已经自动写好了程序入口，这里不用改动了1234567891011121314package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// SpringBootApplication用来注解应用类，在里面的main函数中启动web服务@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;在DemoApplication.java文件同级目录下新建controller包，用来存放路由类，，这里我创建一个第一个路由类文件firstController.java12345678910111213141516171819202122232425262728293031package com.example.demo.controller;import com.example.demo.user.User;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.IOException;// RestController注解用来声明后面的类里面有路由信息@RestControllerpublic class firstController &#123; // RequestMapping注解声明后面的方法是一个路由方法 @RequestMapping("hello") public String Hello(User user)&#123; return "Hello World!" + user.getUsername(); &#125; // 使用HttpServletResponse类型的参数可以直接通过这个response写入响应信息 @RequestMapping("hello1") public void Hello1(HttpServletResponse response)&#123; try &#123; response.getWriter().write("hello1"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 请求转发secondController.java123456789101112131415161718192021222324252627282930313233package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;// Controller注解会根据返回的字符串找到对应的静态文件返回，RestController注解会直接返回字符串作为响应体@Controllerpublic class secondController &#123; @RequestMapping("dispatcher") public String dispatcher()&#123; return "dispatcher1.html"; &#125; @RequestMapping("dispatcher1") public void dispatcher1(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; request.getRequestDispatcher("dispatcher.html").forward(request, response); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;这里dispatcher和dispatcher1是一个效果，都会转发到另外一个页面（dispatcher转发到dispatcher1.html,dispatcher1转发到dispatcher.html） 重定向thirdController.java1234567891011121314151617181920212223package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class thirdController &#123; @RequestMapping(value = "redirect", method = RequestMethod.GET) public String redirectd()&#123; // 返回"dispatcher.html",会默认按照"forward:dispatcher.html"，进行转发 // "redirect:dispatcher.html"，redirect表示重定向，重定向和转发是有区别的，重定向会改变浏览器显示的url地址，转发不会改变 return "redirect:dispatcher.html"; &#125; // 在RequestMapping注解后紧跟ResponseBody注解，和RestController注解类起到相同的效果，即直接将字符串作为响应 @RequestMapping("controller2rescontroller") @ResponseBody public String contrl()&#123; return "this is a string"; &#125;&#125; 模版使用thymeleaf实现模版渲染，在build.gradle 文件里添加插件1234567891011121314151617181920212223242526plugins &#123; id 'org.springframework.boot' version '2.1.3.RELEASE' id 'java'&#125;apply plugin: 'io.spring.dependency-management'group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '1.8'repositories &#123; mavenCentral()&#125;dependencies &#123; implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' // ------------添加thymeleaf插件-------start compile('org.springframework.boot:spring-boot-starter-thymeleaf') compile('org.thymeleaf:thymeleaf:3.0.9.RELEASE') compile('org.thymeleaf:thymeleaf-spring4:3.0.9.RELEASE') compile('nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:2.2.2') // ------------添加thymeleaf插件-------end&#125;添加好插件后就可以渲染模版了，templateController.java123456789101112131415package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class templateController &#123; @RequestMapping("testTemplate") public String testTemplate(Model model)&#123; model.addAttribute("username", "storm"); return "index"; &#125;&#125;这里直接返回index，框架会自动去templates文件夹下寻找对应的index.html文件，同时在html文件里可以使用model的username变量，index.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello! &lt;span th:text="$&#123;username&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;在html标签中写入：xmlns:th=”http://www.thymeleaf.org，就可以通过th来使用model的变量了，使用方式为th:text=&quot;${变量名}&quot;，或者input标签可以使用 th:value=”${变量名}”thymeleaf会严格检查html的完整性，如果html存在标签不完整会报错， 最后，贴一下整个项目的文件结构图]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习（五）-高阶函数]]></title>
    <url>%2F2019%2F02%2F14%2Fkotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin的高阶函数是指将函数作为参数或返回值的函数 将函数作为参数的高阶函数看一下sumBy{}源码： 1234567public inline fun CharSequence.sumBy(selector: (Char) -&gt; Int): Int &#123; var sum: Int = 0 for (element in this) &#123; sum += selector(element) &#125; return sum&#125; sumBy的使用案例： 123val testStr = "abc"val sum = testStr.sumBy &#123; it.toInt() &#125;println(sum) 执行结果为：294备注一下：kotlin官方给出的建议：当高阶函数的参数只有一个函数且这个函数为lambda表达式时，调用高阶函数可以省去（），所以直接函数名后跟上lambda表达式{ it.toInt() }，还有一个约定，即当函数的最后一个参数是一个lambda表达式，则可以在圆括号之外定义它。 函数作为返回值的高阶函数这里可以用闭包的例子来说明 123456789101112fun test(b : Int): () -&gt; Int&#123; var a = 3 return fun() : Int&#123; a++ return a + b &#125;&#125;val t = test(3)println(t())println(t())println(t()) 输出结果为： 123789]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18 安装golang以及对go三个关键环境变量的理解]]></title>
    <url>%2F2019%2F01%2F29%2Fubuntu18-%E5%AE%89%E8%A3%85golang%E4%BB%A5%E5%8F%8A%E5%AF%B9go%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;vps的ip被封，更换ip的同时我顺带把原来的centos换成了ubuntu18,更换之后想着在服务器上重新玩一下golang，在重新安装golang的过程中我对golang的三个关键目录有了更深的理解， 我用的操作系统是Ubuntu 18.04 LTS golang安装 12apt-get updateapt-get install golang 在终端执行这两条命令就可以安装上golang了 go三个关键目录 &emsp;&emsp;go的三个关键环境变量为GOPATH、GOBIN、GOROOT&emsp;&emsp;GOPATH用来指定工作空间的目录，通常会在家目录下创建一个文件夹并添加到gopath，在设置gopath之前，先看下go env执行命令：go env可以看到 123456789101112131415161718192021222324root@ubuntu:~/go/src# go envGOARCH="amd64"GOBIN=""GOCACHE="/root/.cache/go-build"GOEXE=""GOHOSTARCH="amd64"GOHOSTOS="linux"GOOS="linux"GOPATH="/opt/go"GORACE=""GOROOT="/usr/lib/go-1.10"GOTMPDIR=""GOTOOLDIR="/usr/lib/go-1.10/pkg/tool/linux_amd64"GCCGO="gccgo"CC="gcc"CXX="g++"CGO_ENABLED="1"CGO_CFLAGS="-g -O2"CGO_CPPFLAGS=""CGO_CXXFLAGS="-g -O2"CGO_FFLAGS="-g -O2"CGO_LDFLAGS="-g -O2"PKG_CONFIG="pkg-config"GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build634430698=/tmp/go-build -gno-record-gcc-switches" 在使用apt-get install golang后，apt-get会自动将安装包目录作为GOROOT，且GOROOT只能设置为安装包路径，这里的GOROOT为/usr/lib/go-1.10 在没有设置环境变量之前GOPATH是默认指向/opt/go的，GOBIN为空 需要注意的是不同的系统，不同的安装方式，会导致上面三个目录有所不同，至少我在mac上和ubuntu里安装后这三个路径不一样，这个时候其实我们也可以到gopath指定的路径/opt/go下进行开发，但是我更喜欢在家目录下开发， 这里记一下这三个目录的作用GOPATH为工作空间的路径，比如我在home目录下创建一个go文件夹来作为开发空间，那么需要在家目录下创建go文件夹12345678//cd 到家目录cd// 创建go文件夹mkdir gocd gomkdir srcmkdir pkgmkdir bin编辑～/.bashrc 文件:vi ~/.bashrc往里面追加一下内容1export GOPATH=/root/go GOBIN用来存放项目编译生成的可执行文件，在使用go install命令的时候会将生成的可执行二进制文本放到这个目录下，所以我们需要将之前在工作空间创建的bin路径放到GOBIN变量里在～/.bashrc 文件中追加：1export GOBIN=/root/go/bin这儿如果不设置GOBIN的话，go install的时候会报错：1go install: no install location for .go files listed on command line (GOBIN not set)另外每次编辑～/.bashrc文件后需要soure一下 至此三个环境变量已经介绍完了，做个总结：GOPATH设置工作空间，GOROOT指向安装包目录，GOBIN指向用来存放编译生成的可执行文件的目录 小测试一下切换到工作空间的src目录下，创建一个hello目录，并进入hello目录123cd ~/go/srcmkdir hellocd hello创建hello.go文件vi hello.go写入代码：123456package mainimport "fmt"func main()&#123;fmt.Println("hello world")&#125;编译文件：go build ~/go/src/hello/hello.go如果环境变量配置正确，会在～/go/bin/目录下多出一个hello的可执行文件，.~/go/bin/hello 就会输出hello world]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习（四）-面向对象]]></title>
    <url>%2F2019%2F01%2F23%2Fkotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 写在本文之前：&emsp;&emsp;本文中会用到kotlin转java代码，所以这里附上使用intellij IDEA将kotlin转成java的方法：在idea中选中要查看的文件，在菜单栏中点击tools，找到kotlin，点击kotlin找到show kotlin bytecode,点击后会在窗口右边显示字节码，在字节码窗口的左上角有一个decompile，点击decompile就可以反编译成java代码 kotlin的面向对象在java的基础上做了很大的优化 访问器在面向对象中，很多场景我们会对属性做一些限制，比如对某个属性只允许访问，不准修改，还有在对一些属性进行赋值时会进行一些校验 1234567891011121314151617181920212223fun main(arg: Array&lt;String&gt;) &#123; var h = Human() println(h.name) println(h.age) // h.name = "李四" h.age = 20 println(h.name) println(h.age)&#125;class Human()&#123; var name:String = "张三" private set var age: Int = 18 set(value) &#123; if (value &lt; 200) &#123; // this.age = value field = value &#125; &#125;&#125; 比如在这个例子中，我们要求不允许对象对name字段进行修改，那么只需要在属性下一行紧跟着使用private set，就可以将禁止对该属性进行修改，对age字段我们允许对象进行修改，但是要求年龄不允许超过200岁，所以重写在age字段后面重写set方法，就可以在赋值的时候进行一些预校验，这里需要强调的时候在set方法内，不要使用this来赋值，否则会栈溢出通过kotlin字节码反编译成java代码，我们可以发现，在kotlin中定义的属性，会在转化成java时默认加上private权限，同时定义get和set方法，我们使用private修饰set后反编译成 Java，可以知道这相当于给set方法加了一个private属性，具体请看下面反编译生成java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// TestKt.javaimport kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 2, d1 = &#123;"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"&#125;, d2 = &#123;"main", "", "arg", "", "", "([Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class TestKt &#123; public static final void main(@NotNull String[] arg) &#123; Intrinsics.checkParameterIsNotNull(arg, "arg"); Human h = new Human(); String var2 = h.getName(); System.out.println(var2); int var3 = h.getAge(); System.out.println(var3); h.setAge(20); var2 = h.getName(); System.out.println(var2); var3 = h.getAge(); System.out.println(var3); &#125;&#125;// Human.javaimport kotlin.Metadata;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;"\u0000\u001c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000e\n\u0002\b\u0006\u0018\u00002\u00020\u0001B\u0005¢\u0006\u0002\u0010\u0002R$\u0010\u0005\u001a\u00020\u00042\u0006\u0010\u0003\u001a\u00020\u0004@FX\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\u0006\u0010\u0007\"\u0004\b\b\u0010\tR$\u0010\f\u001a\u00020\u000b2\u0006\u0010\n\u001a\u00020\u000b@BX\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\r\u0010\u000e\"\u0004\b\u000f\u0010\u0010¨\u0006\u0011"&#125;, d2 = &#123;"LHuman;", "", "()V", "value", "", "age", "getAge", "()I", "setAge", "(I)V", "&lt;set-?&gt;", "", "name", "getName", "()Ljava/lang/String;", "setName", "(Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class Human &#123; @NotNull private String name = "张三"; private int age = 18; @NotNull public final String getName() &#123; return this.name; &#125; private final void setName(String var1) &#123; this.name = var1; &#125; public final int getAge() &#123; return this.age; &#125; public final void setAge(int value) &#123; if (value &lt; 200) &#123; this.age = value; &#125; &#125;&#125; init方法 1234567891011121314fun main(arg: Array&lt;String&gt;) &#123; var h = Human("李四", 23) println(h.name) println(h.age)&#125;class Human(name: String, age: Int)&#123; var name: String = "" var age: Int = 0 init &#123; this.name = name this.age = age &#125;&#125; init定义的是构造方法，这里面的逻辑最终会编译到java的构造函数中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// TestKt.javaimport kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 2, d1 = &#123;"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"&#125;, d2 = &#123;"main", "", "arg", "", "", "([Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class TestKt &#123; public static final void main(@NotNull String[] arg) &#123; Intrinsics.checkParameterIsNotNull(arg, "arg"); Human h = new Human("李四", 23); String var2 = h.getName(); System.out.println(var2); int var3 = h.getAge(); System.out.println(var3); &#125;&#125;// Human.javaimport kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;"\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u000e\n\u0000\n\u0002\u0010\b\n\u0002\b\n\u0018\u00002\u00020\u0001B\u0015\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0005¢\u0006\u0002\u0010\u0006R\u001a\u0010\u0004\u001a\u00020\u0005X\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\u0007\u0010\b\"\u0004\b\t\u0010\nR\u001a\u0010\u0002\u001a\u00020\u0003X\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\u000b\u0010\f\"\u0004\b\r\u0010\u000e¨\u0006\u000f"&#125;, d2 = &#123;"LHuman;", "", "name", "", "age", "", "(Ljava/lang/String;I)V", "getAge", "()I", "setAge", "(I)V", "getName", "()Ljava/lang/String;", "setName", "(Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class Human &#123; @NotNull private String name; private int age; @NotNull public final String getName() &#123; return this.name; &#125; public final void setName(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.name = var1; &#125; public final int getAge() &#123; return this.age; &#125; public final void setAge(int var1) &#123; this.age = var1; &#125; public Human(@NotNull String name, int age) &#123; Intrinsics.checkParameterIsNotNull(name, "name"); super(); this.name = ""; this.name = name; this.age = age; &#125;&#125; 使用var和val的方式定义构造方法 123456789101112fun main(arg: Array&lt;String&gt;) &#123; var h = Human("李四", 23) println(h.name) println(h.age) // h.name = "ss" h.age = 24 println(h.age)&#125;class Human(val name: String, var age: Int)&#123;&#125; 这段代码中定义类只用了一行代码，但它和上面的代码有同样的效果，即name不可修改，age可修改只不过通过查看反编译后的java代码可以发现，这和private set还是有区别的，privata是将set方法设置为私有，而val定义的方式不会生成set方法，因为属性是私有的，所有同样可以起到不允许修改的作用 次构造方法（构造方法重载）在我的理解看来kotlin的次构造方法就相当于java的构造方法重载，kotlin次构造函数使用方法如下 1234567891011121314151617181920fun main(arg: Array&lt;String&gt;) &#123; var h = Human("李四", 23) println(h.name) println(h.age) println(h.phone) // h.name = "ss" h.age = 24 println(h.age) var h1 = Human("王五", 40, "13788888888") println(h1.name) println(h1.age) println(h1.phone)&#125;class Human(val name: String, var age: Int)&#123; var phone: String = "" constructor(name:String,age:Int,phone:String):this(name, age)&#123; this.phone = phone &#125;&#125; constructor就是定义次构造函数的关键词查看对应的java代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// TestKt.javaimport kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 2, d1 = &#123;"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"&#125;, d2 = &#123;"main", "", "arg", "", "", "([Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class TestKt &#123; public static final void main(@NotNull String[] arg) &#123; Intrinsics.checkParameterIsNotNull(arg, "arg"); Human h = new Human("李四", 23); String var2 = h.getName(); System.out.println(var2); int var4 = h.getAge(); System.out.println(var4); var2 = h.getPhone(); System.out.println(var2); h.setAge(24); var4 = h.getAge(); System.out.println(var4); Human h1 = new Human("王五", 40, "13788888888"); String var3 = h1.getName(); System.out.println(var3); int var6 = h1.getAge(); System.out.println(var6); var3 = h1.getPhone(); System.out.println(var3); &#125;&#125;// Human.javaimport kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import org.jetbrains.annotations.NotNull;@Metadata( mv = &#123;1, 1, 13&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;"\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u000e\n\u0000\n\u0002\u0010\b\n\u0002\b\r\u0018\u00002\u00020\u0001B\u001f\b\u0016\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0005\u0012\u0006\u0010\u0006\u001a\u00020\u0003¢\u0006\u0002\u0010\u0007B\u0015\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0005¢\u0006\u0002\u0010\bR\u001a\u0010\u0004\u001a\u00020\u0005X\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\t\u0010\n\"\u0004\b\u000b\u0010\fR\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\r\u0010\u000eR\u001a\u0010\u0006\u001a\u00020\u0003X\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\u000f\u0010\u000e\"\u0004\b\u0010\u0010\u0011¨\u0006\u0012"&#125;, d2 = &#123;"LHuman;", "", "name", "", "age", "", "phone", "(Ljava/lang/String;ILjava/lang/String;)V", "(Ljava/lang/String;I)V", "getAge", "()I", "setAge", "(I)V", "getName", "()Ljava/lang/String;", "getPhone", "setPhone", "(Ljava/lang/String;)V", "kotlin_practice"&#125;)public final class Human &#123; @NotNull private String phone; @NotNull private final String name; private int age; @NotNull public final String getPhone() &#123; return this.phone; &#125; public final void setPhone(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.phone = var1; &#125; @NotNull public final String getName() &#123; return this.name; &#125; public final int getAge() &#123; return this.age; &#125; public final void setAge(int var1) &#123; this.age = var1; &#125; public Human(@NotNull String name, int age) &#123; Intrinsics.checkParameterIsNotNull(name, "name"); super(); this.name = name; this.age = age; this.phone = ""; &#125; public Human(@NotNull String name, int age, @NotNull String phone) &#123; Intrinsics.checkParameterIsNotNull(name, "name"); Intrinsics.checkParameterIsNotNull(phone, "phone"); this(name, age); this.phone = phone; &#125;&#125; 从Java代码最后的两个构造方法可以看出，constructor其实就是定义了构造函数的重载 init 和constructor的执行顺序init先于constructor执行]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习（三）]]></title>
    <url>%2F2019%2F01%2F22%2Fkotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; for循环 1234fun main(arg: Array&lt;String&gt;) &#123; var a: Int? = null println(a)&#125; 跳出循环和其他语言的continue 和break 用法一致 foreach循环 123456fun main(arg: Array&lt;String&gt;) &#123; var a = "storm" a.forEach &#123; println(it) &#125;&#125; 退出循环跳到指定标签处 12345678910111213fun main(arg: Array&lt;String&gt;) &#123; var a = "storm" var b = "super" tag_demo@for (i in a)&#123; for (j in b)&#123; println("i:$i ,j:$j ") if (i=='m'&amp;&amp; j == 's')&#123; break@tag_demo &#125; &#125; &#125; println("执行结束")&#125; 使用@符号定义标签，类似c语言中的goto语法，先定义一个标签，然后在break、continue、return的时候均可以@跟标签名，跳转到指定位置此处需要注意的是kotlin中”双引号表示字符串，’单引号表示字符，”双引号内尽管只有一个字符也算字符串不能直接和单个字符进行比较 区间区间可以定义一个指定范围的迭代器，相比于声明一个同样的数组，可以明显的节省内存，提高代码效率 1234567891011121314fun main(arg: Array&lt;String&gt;) &#123; var a = 1..100 for (i in a)&#123; println(i) &#125; var b = IntRange(1,100) for (i in b)&#123; println(i) &#125; var c = 1.rangeTo(100) for (i in c)&#123; println(i) &#125;&#125; 见名知义，定义区间有三种形式，第一种使用..,第二种使用基本数据类型对应的区间类型，第三种使用基础类型值的rangeToapi区间还有另外两种遍历方式 123456789fun main(arg: Array&lt;String&gt;) &#123; var a = 1..100 a.forEachIndexed&#123;index, i -&gt; println("index: $index ,i: $i ") &#125; for ((index, i) in a.withIndex())&#123; println("index: $index ,i: $i ") &#125;&#125; 区间反转 12345678910111213141516fun main(arg: Array&lt;String&gt;) &#123; // 反向区间 var a = 100 downTo 1 for (i in a)&#123; println(i) &#125; // 区间反转 var b = a.reversed() for(i in b)&#123; println(i) &#125; for (i in b step 5)&#123; println(i) &#125;&#125; 数组 123456789101112131415161718fun main(arg: Array&lt;String&gt;) &#123; var a = arrayOf('a','b','c') var b = arrayOf("string","string") var c = arrayOf(1,2,3) var d = arrayOf("string",'c', 1) var e = IntArray(20)&#123;1&#125; // 定义一个大小为20，初始值为1的整型数组 println(a) println(b) println(c) println(d) println(e) println(a.indexOf('a')) println(a.lastIndexOf('b')) println(a.indexOfFirst &#123; it.equals('c') &#125;)&#125; whenjava中有switch，那么kotlin中的when语句就相当于java的switch，不过kotlin的when做了加强，它可以允许不带参数，且可以有返回值 123456789101112131415fun main(arg: Array&lt;String&gt;) &#123; var a = 60 when&#123; a &lt; 60-&gt;&#123; println("不及格") &#125; a in 60..80 -&gt;&#123; println("及格") &#125; a &gt; 80 -&gt;&#123; println("优秀") &#125; &#125;&#125; 异常 12345678910111213fun main(arg: Array&lt;String&gt;) &#123; var a = 2 var b = 0 try &#123; print(a/b) &#125;catch (e: ArithmeticException)&#123; println("除数不能为零") &#125; finally &#123; println("finnaly") &#125;&#125; 面向对象 1234567891011121314151617181920212223242526fun main(args: Array&lt;String&gt;) &#123; val girl = Girl() println(girl.name) println(girl.age) girl.greeting() val rect = Rect() println(rect.long) println(rect.width)&#125;//矩形class Rect&#123; //静态属性 var long:Int = 100 var width:Int = 100&#125;//妹子class Girl&#123; //静态属性 var name:String = "李四" var age:Int = 20 //动态行为 fun greeting()&#123; println("hello 你好") &#125;&#125; 运算符重载kotlin中支持运算符重载，这点和c++的运算符重载很像，也是根据操作对象属性来定义的重载定义关键字operator 12345678910111213141516171819202122232425262728fun main(args: Array&lt;String&gt;) &#123; var a = 10 var b = 20 a.plus(b) val girl1 = Girl() val girl2 = Girl() girl2.name = "王五" val newGirl = girl1 + girl2 println(newGirl)// println(newGirl.age)&#125;class Girl&#123; //定义对应的运算符函数// operator fun plus(girl:Girl):Girl&#123;// return this// &#125;// operator fun plus(age:Int):Girl&#123;// this.age += age// return this// &#125; operator fun plus(girl:Girl):Int&#123; return this.age+girl.age &#125; var name:String = "张三" var age:Int = 20&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习（二）-可空类型]]></title>
    <url>%2F2019%2F01%2F21%2Fkotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;据统计，市场上java程序的bug超过50%都是空指针异常，那么kotlin为了改善这个问题，加入了可空类型，在java程序中，变量可以直接赋值为null，但是在kotlin中不能这样1234fun main(arg: Array&lt;String&gt;) &#123; var a: Int = null println(a)&#125;以上代码在编译的时候会报错，提示： error: null can not be a value of a non-null type Int那么如果想要a变量可以赋值为null可以使用可空类型标示符”?” 可空类型 1234fun main(arg: Array&lt;String&gt;) &#123; var a: Int? = null println(a)&#125; 在类型声明后面跟一个？号就可以定义一个可空变量，由可空类型又引出了安全调用符以及Elvis运算符 安全调用符如果不使用安全调用符”？”对可空对象进行方法调用，编译会出错 12345fun main(arg: Array&lt;String&gt;) &#123; var a: String? = null var b: Int = a.toInt() println(b)&#125; 以上代码编译的时候会报： 1error: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? 第一种解决办法，使用提示建议的非空断言”！！”告诉编译器这个对象不可能为空 12345fun main(arg: Array&lt;String&gt;) &#123; var a: String? = null var b: Int = a!!.toInt() println(b)&#125; 但是这样做虽然可以编译通过，但是在执行时仍然会报空指针异常 1Exception in thread "main" kotlin.KotlinNullPointerException 所以另一种解决办法为使用安全调用符”？” 12345fun main(arg: Array&lt;String&gt;) &#123; var a: String? = null var b: Int? = a?.toInt() println(b)&#125; 使用安全调用符的同时需要将接受对象声明为可空类型 Elvis运算符在上面提到的对可空对象进行操作时，如果操作目标为空值则返回的是null或者空指针异常，那么使用Elvis运算符可以修改为空时返回的值 12345fun main(arg: Array&lt;String&gt;) &#123; var a: String? = null var b: Int? = a?.toInt()?: -1 println(b)&#125; 使用Elvis运算符后程序打印结果为-1]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记5（多线程）]]></title>
    <url>%2F2019%2F01%2F15%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;java提供了三种方式创建线程，实现runnable接口、继承thread类、通过callable和future创建线程 runnable接口实现线程 123456789101112131415161718192021222324252627282930313233class RunnableThread implements Runnable &#123; String name = null; public RunnableThread(String name)&#123; this.name = name; &#125; public void run()&#123; System.out.println("子线程run"); try &#123; for (int i = 5; i &gt; 0; i--) &#123; System.out.println(this.name + ":" + i); Thread.sleep(500); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void start()&#123; System.out.println(this.name + "开始执行"); Thread t = new Thread(this, this.name); t.start(); &#125;&#125;public class test3 &#123; public static void main(String[] args)&#123; RunnableThread th1 = new RunnableThread("thread1"); th1.start(); RunnableThread th2 = new RunnableThread("thread2"); th2.start(); &#125;&#125; 继承thread 123456789101112131415161718192021222324252627282930313233class InheritThread extends Thread&#123; String name = null; public InheritThread(String name)&#123; this.name = name; &#125; public void run()&#123; System.out.println("子线程run"); try &#123; for (int i = 5; i &gt; 0; i--) &#123; System.out.println(this.name + ":" + i); Thread.sleep(500); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void start()&#123; System.out.println(this.name + "开始执行"); Thread t = new Thread(this, this.name); t.start(); &#125;&#125;public class test3 &#123; public static void main(String[] args)&#123; InheritThread th1 = new InheritThread("thread1"); th1.start(); InheritThread th2 = new InheritThread("thread2"); th2.start(); &#125;&#125; 实现callable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;import java.util.concurrent.ExecutionException;class CallableThread implements Callable&lt;Integer&gt; &#123; String name = null; public CallableThread(String name)&#123; this.name = name; &#125; public Integer call()&#123; System.out.println("子线程run"); try &#123; for (int i = 5; i &gt; 0; i--) &#123; System.out.println(this.name + ":" + i); Thread.sleep(500); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; return 1; &#125;&#125;public class test3 &#123; public static void main(String[] args)&#123; CallableThread c1 = new CallableThread("c1"); FutureTask&lt;Integer&gt; f1 = new FutureTask&lt;&gt;(c1); new Thread(f1, "thread1").start(); CallableThread c2 = new CallableThread("c2"); FutureTask&lt;Integer&gt; f2 = new FutureTask&lt;&gt;(c2); new Thread(f2, "thread2").start(); try&#123; System.out.println(f1.get()); System.out.println(f2.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记4（IO流）]]></title>
    <url>%2F2019%2F01%2F15%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%EF%BC%88IO%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Java的stream按方向可以分为：输出流，输入流；按操作可以分为字节流，字符流。字节流和字符流都有输入和输出两个方向 字节流 字节输入流以字节读取文件内容,每次读取一个字节： 123456789101112131415import java.io.*;import java.io.File;import java.io.FileInputStream;public class test3 &#123; public static void main(String[] args)throws IOException&#123; File file = new File("test.txt"); FileInputStream fis = new FileInputStream(file); int b; while (( b = fis.read()) != -1)&#123; System.out.println((char)b); &#125; fis.close(); &#125;&#125; 以字节读取文件内容,每次读取多个字节： 12345678910111213141516import java.io.*;import java.io.File;import java.io.FileInputStream;public class test3 &#123; public static void main(String[] args)throws IOException&#123; File file = new File("test.txt"); FileInputStream fis = new FileInputStream(file); byte[] bys = new byte[1028]; int len = 0; while (( len = fis.read(bys)) != -1)&#123; System.out.write(bys,0,len); &#125; fis.close(); &#125;&#125; 字节输出流 12345678910111213import java.io.*;import java.io.File;public class test3 &#123; public static void main(String[] args)throws IOException&#123; File file = new File("test.txt"); String s = "this is storm'blog"; byte[] s1 = s.getBytes(); FileOutputStream fos = new FileOutputStream(file,true); fos.write(s1); fos.close(); &#125;&#125; 字符输入流以字符为单位读取文件内容，在字节编码中，gbk格式一个中文站两个字节，utf-8 格式中一个中文占三个字节，所以在操作中文内容的时候，使用字符流比字节流更方便 字符流输入123456789101112131415161718import java.io.*;import java.io.File;public class test3 &#123; public static void main(String[] args)throws IOException&#123; File file = new File("test.txt"); FileInputStream fis = new FileInputStream(file); InputStreamReader ifr = new InputStreamReader(fis); char ch; ch = (char)ifr.read(); System.out.println(ch); char[] chs = new char[1024]; ifr.read(chs); System.out.println(chs); fis.close(); ifr.close(); &#125;&#125; 字符流输出1234567891011121314import java.io.*;import java.io.File;public class test3 &#123; public static void main(String[] args)throws IOException&#123; File file = new File("test.txt"); FileOutputStream fos = new FileOutputStream(file,true); // true 为缺省参数append的值，表示是否追加模式打开 OutputStreamWriter osw = new OutputStreamWriter(fos, "utf-8"); osw.write("你好"); osw.close(); // 关闭流的时候应该先关闭字符输出流，再关闭文件输出流，否则先关闭文件输出流会抛io异常 fos.close(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习（一）]]></title>
    <url>%2F2019%2F01%2F14%2Fkotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin语言是ide开发公司JetBrains 出品的一个基于jvm的静态类型编程语言，2017年5月17日在旧金山召开的I/O开发者大会上，谷歌宣布Kotlin语言同java和C++一样成为Android的官方语言。 安装macOS操作系统可以使用homebrew安装 12brew updatebrew install kotlin hello world创建test.kt文件，写入代码 123fun main(args: Array&lt;String&gt;)&#123; println("hello world!")&#125; 编译 1kotlinc test.kt -include-runtime -d hello.jar kotlinc 为编译指令，test.kt 要编译的文件， -include-runtime 表示包含kotlin运行时需要的库， -d 指定编译后的文件输出路径执行 1kotlin hello.jar 如果环境配置正确就可以正常输出”hello world!”啦，记一下我配置kotlin环境时遇到的坑，在kotlinc编译时报错，提示: 1Exception in thread "main" java.lang.UnsupportedClassVersionError: org/jetbrains/kotlin/preloading/Preloader : Unsupported major.minor version 52.0 通过搜索得知，这应该是jdk版本不对应导致的，kotlinc在这里使用的是jdk 1.8 ,而我之前写java代码时，安装的jdk版本是1.7，安装jdk 1.8,设置java环境变量为jdk1.8的路径就可以正常编译了 变量声明 12345678910fun main(args: Array&lt;String&gt;)&#123; // 可变变量 var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; // 不可变变量val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; val a: Int = 10 var b: Int = 20 // a = 20 err :val修饰的变量不能修改 b = 15 println(a) println(b)&#125; 函数定义函数定义关键子为fun 参数定义使用 形参名: 类型 123456fun sum(a: Int, b: Int): Int&#123; return a + b&#125;fun main(args: Array&lt;String&gt;)&#123; println(sum(3, 5))&#125; 可变长参数可变长形参关键字vararg 12345678910fun sum(vararg arg: Int): Int&#123; var result: Int = 0 for (v in arg)&#123; result += v &#125; return result&#125;fun main(args: Array&lt;String&gt;)&#123; println(sum(1,2,3,4,5,6))&#125; lambda(匿名函数) 1234fun main(args: Array&lt;String&gt;)&#123; val suml_lambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(suml_lambda(2,3))&#125; 字符串模版$ 表示一个变量名或者变量值$varName 表示变量值${varName.fun()} 表示变量的方法返回值 12345678910fun main(arg: Array&lt;String&gt;) &#123; var a = 1// 模板中的简单名称： val s1 = "a 的旧值是 $a" a = 2// 模板中的任意表达式： val s2 = "$&#123;s1.replace("is", "was")&#125;, 现在修改后的值是 $a" println(s2)&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记3-文件操作]]></title>
    <url>%2F2019%2F01%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 创建文件 123456789101112131415161718import java.io.File;import java.io.IOException;public class test3 &#123; public static void main(String[] args)&#123; File file = new File("test.txt"); if (!file.exists())&#123; try &#123; file.createNewFile(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; if (file.exists())&#123; System.out.println("创建成功"); &#125; &#125; &#125; 创建文件夹 12345678910111213import java.io.File;public class test3 &#123; public static void main(String[] args)&#123; File file = new File("test_dir"); if (!file.exists())&#123; file.mkdirs(); &#125; if (file.exists())&#123; System.out.println("创建成功"); &#125; &#125; &#125; 删除文件 12345678910111213import java.io.File;public class test3 &#123; public static void main(String[] args)&#123; File file = new File("test.txt"); if (file.exists())&#123; file.delete(); &#125; if (!file.exists())&#123; System.out.println("删除成功"); &#125; &#125; &#125; 删除文件夹 1234567891011121314151617import java.io.File;public class test3 &#123; public static void main(String[] args)&#123; File file = new File("test_dir"); if (file.isDirectory() &amp;&amp; file.exists())&#123; File[] files = file.listFiles(); for (File file1: files)&#123; file1.delete(); &#125; file.delete(); &#125; if (!file.exists())&#123; System.out.println("删除成功"); &#125; &#125; &#125; 如果目录有子目录，可以定义一个递归方法遍历删除 读文件 以二进制读取文件（图片，视频，音频等二进制文件）12345678910111213141516171819202122232425262728293031//import com.sun.org.apache.xpath.internal.operations.String;import java.io.*;import java.io.File;import java.io.FileInputStream;public class test3 &#123; public static void main(String[] args)&#123; System.out.println("a"); File file = new File("2.png"); if (!file.exists() || ! file.isFile())&#123; System.out.println("打开文件失败，非文件或文件不存在！"); &#125; StringBuffer content = new StringBuffer(); try&#123; byte[] temp = new byte[1024]; FileInputStream fileInputStream = new FileInputStream(file); while (fileInputStream.read(temp) != -1)&#123; content.append(new String(temp)); temp = new byte[1024]; &#125; fileInputStream.close(); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; System.out.println(content.toString()); &#125;&#125; 这里记一个坑：由于ide（intellij IDEA CE）自己误倒入了com.sun.org.apache.xpath.internal.operations.String包。导致编译时提示123警告: String是内部专用 API, 可能会在未来发行版中删除 public static void main(String[] args)&#123; ^]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记2]]></title>
    <url>%2F2019%2F01%2F10%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; HashMap 的遍历1234567891011import java.util.HashMap;public class test3 &#123; public static void main(String[] args)&#123; HashMap&lt;String, String&gt; dic = new HashMap&lt;&gt;(); dic.put("name","storm"); dic.put("sex","man"); for (String key : dic.keySet())&#123; System.out.println(key + ":" + dic.get(key)); &#125; &#125;&#125; ArrayListArrayList 和数组的区别有点类似go语言中切片和数组的区别，数组是一种静态的数据类型，长度固定，类型固定，而ArrayList的长度可以扩展且数据类型可以是任意类型（如果定义时不加任何泛型则可以存放任意类型） 123456789101112131415import java.util.ArrayList;public class test3 &#123; public static void main(String[] args)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("super"); list.add("storm"); list.add("java"); System.out.println(list.toString()); list.set(0, "fx"); System.out.println(list.toString()); list.remove("fx"); System.out.println(list.toString()); System.out.println(list.indexOf("java")); &#125;&#125; java 继承java继承使用extends关键字在任意目录下创建三个文件分别为test3.java test2.java test1.java写入代码test3.java test3.java1234567891011public class test3 &#123; public String name; private int age; public test3(String name, int age)&#123; this.name = name; this.age = age; &#125; public void show()&#123; System.out.println(this.age); &#125;&#125; test2.java test2.java12345public class test2 extends test3&#123; public test2(String name, Integer age)&#123; super(name,age); &#125;&#125; test1.java test1.java1234567public class test1 &#123; public static void main(String[] args)&#123; test2 test = new test2("storm", 18); System.out.println(test.name); test.show(); &#125;&#125; 编译后运行test1。 1234javac test3.javajavac test2.javajavac test1.javajava test1 运行结果： 12storm18 值得注意的是java不支持多继承，只能多层继承，根据官方的意思是java多继承容易引起歧义，即如果继承的两个父类有同名的方法，编译器不知道子类中该指向哪个方法，另外java继承中子类不能访问父类对其不可见的变量，例如private修饰的变量 interface 接口接口是一个对方法的抽象集合，即一个接口声明了堆需要实现的方法，但它不实现方法代码体，也不能直接实例化，，可以多继承，java类是不能多继承的在任意目录下创建三个文件分别为test3.java test2.java test1.javatest1.java 声明接口 1234public interface test1 &#123; public void work(); public void study();&#125; test2.java 实现接口关键字implements，注意，一个类如果实现接口，要么全部实现接口中的方法，要么声明为抽象类 12345678910import org.omg.Messaging.SYNC_WITH_TRANSPORT;public class test2 implements test1&#123; public void work()&#123; System.out.println("work"); &#125; public void study()&#123; System.out.println("study"); &#125;&#125; test3.java 实例化，调用接口方法 1234567public class test3 &#123; public static void main(String[] args)&#123; test2 test = new test2()&#123;&#125;; test.study(); test.work(); &#125;&#125; 编译，执行 1234javac test1.javajavac test2.javajavac test3.javajava test3 输出结果 12studywork Java的异常代码 12345678910111213141516171819public class test3 &#123; public static void main(String[] args)&#123; int[] a = new int[2]; try&#123; int b = a[3]; &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println("catch exception1:" + e); &#125;finally &#123; System.out.println("finally exec1"); &#125; try&#123; throw new ArrayIndexOutOfBoundsException(4); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println("catch exception2:" + e); &#125;finally &#123; System.out.println("finally exec2"); &#125; &#125;&#125; 编译后执行的结果为： 1234catch exception1:java.lang.ArrayIndexOutOfBoundsException: 3finally exec1catch exception2:java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 4finally exec2]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记1]]></title>
    <url>%2F2019%2F01%2F08%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;java是sun公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。 hello world安装好jdk后，创建一个test.java文件，写入以下代码123456public class test1&#123; public static void main(String[] args)&#123; System.out.println("hello world!"); &#125;&#125;保存后，在终端切到文件对应目录，运行javac test.java编译文件，编译后在当前目录会生成一个test1.class文件，在终端直接执行java test1，就会打印出hello world！ 变量声明 1234567public class test1&#123; public static void main(String[] args)&#123; // 变量声明方式： 变量类型 变量名 [= value]; String name = "storm"; System.out.println(name); &#125;&#125; 变量类型 123456int a, b, c; // 声明三个int型整数：a、 b、cint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值byte z = 22; // 声明并初始化 zString s = "runoob"; // 声明并初始化字符串 sdouble pi = 3.14159; // 声明了双精度浮点型变量 pichar x = 'x'; // 声明变量 x 的值是字符 'x'。 条件判断 1234567891011121314151617181920212223public class test2 &#123; public static void main(String[] args)&#123; /* if (条件1)&#123; 逻辑1 &#125;else if (条件2)&#123; 逻辑2 &#125;else&#123; 逻辑3 &#125; */ int a = 59; if ( a &gt;= 80 )&#123; System.out.println("优秀"+a); &#125;else if (a&lt; 60)&#123; System.out.println("不及格"+a); &#125;else &#123; System.out.println("良好"+a); &#125; &#125;&#125; 循环 1234567891011121314151617public class test2 &#123; public static void main(String[] args)&#123; for (int i = 0;i&lt;10;i+=1)&#123; System.out.println("0"); &#125; int j = 10; while (j&gt;0)&#123; System.out.println("1"); j-=1; &#125; int k = 0; do &#123; System.out.println("2"); k += 1; &#125;while (k&lt;10); &#125;&#125; 类和方法 1234567891011121314151617public class test2 &#123; public static void main(String[] args)&#123; for (int i = 0;i&lt;10;i+=1)&#123; System.out.println("0"); &#125; int j = 10; while (j&gt;0)&#123; System.out.println("1"); j-=1; &#125; int k = 0; do &#123; System.out.println("2"); k += 1; &#125;while (k&lt;10); &#125;&#125; 修饰符java修饰符有访问修饰符和非访问修饰符 访问修饰符有public,protected,private,default, public修饰的成员对任何类的成员可见 protected修饰的成员对同一包下的类成员和子类成员可见 default修饰的成员只对同包下的类成员访问，子类不可访问 private修饰的成员只能被自身的类访问，2。 非访问修饰符有static,final,abstract，transient，volatile，synchronized static修饰类表示内部类，可以直接实例化；修饰方法不需要实例对象也可以访问，修饰变量所有实例都可以访问 final修饰类不可以继承，修饰方法不可以重写，修饰变量不可以修改 abstract修饰类不可以实例化，即使用必须继承，修饰方法没有实现，子类必须要实现 transient，修饰变量，无需序列化 violate修饰变量，用于多线程，在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 synchronized修饰方法使方法同一时间只能被一个线程访问 包封装的实验创建目录package1，切换到package1里，创建第一个java文件test1.java,写入代码 package1/test1.java1234567package package1;public class test1 &#123; public void myprint()&#123; System.out.println("hello"); &#125;&#125; 创建第二个java文件，test2.java,写入代码 package1/test1.java1234567package package1;public class test2 &#123; public static void main(String[] args)&#123; test1 test22 = new test1(); test22.myprint(); &#125;&#125; 切换到package1同级目录下，javac package1/test1.java ;javac package1/test2.java 编译文件，然后运行，java package1.test2 输出”hello”若要在其他包下面使用myprint方法，可以使用import package1.test1; 语句导入 HashMap普通数组通过下标作为内容索引，而map使用自定义key进行对value的索引 package1/test1.java12345678910import java.util.HashMap;public class test3 &#123; public static void main(String[] args)&#123; HashMap&lt;String, String&gt; dic = new HashMap&lt;&gt;(); dic.put("name","storm"); dic.put("sex","man"); System.out.println(dic); System.out.println(dic.get("name")); &#125;&#125; 输出结果为：{sex=man, name=storm}stormput还可以用来修改某一个已存在的key对应的值，例如dic.put(“name”,”fx”); 就可以将name对应的value改为fx，更多详细用法这里就不一一列出了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go学习笔记6-锁（Mutex和RWMutex）]]></title>
    <url>%2F2019%2F01%2F04%2Fgo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E9%94%81%EF%BC%88Mutex%E5%92%8CRWMutex%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Go 语言提供两类锁: 互斥锁(Mutex)和读写锁(RWMutex)。其中读写锁(RWMutex)是基于互斥锁(Mutex)实现的，锁的定义源码：sync/mutex.go12345678910111213type Mutex struct &#123; state int32 sema uint32&#125;type Locker interface &#123; Lock() Unlock()&#125;func (m *Mutex) Lock()func (m *Mutex) Unlock()&emsp;&emsp;下面用代码来体现互斥锁的用处1234567891011121314151617181920212223package mainimport ( "fmt" "sync")func add(i *int)&#123; for k :=0;k&lt;10000000;k++&#123; *i ++ &#125; wg.Done()&#125;func main()&#123; i := 0 go add(&amp;i) go add(&amp;i) wg.Add(2) wg.Wait() fmt.Println(i) &#125;add 函数作用是传入的值加一千万次1，顺便引入go语法，golang语言中go是异步实现的关键词，使用go之后就可以将对应的函数放到goroutine中，由go自身的机制去异步执行，实现高并发，那么在这个代码中我的目的是为了将i增加到两千万，但是实际上使用goroutine后，i最后的结果只有一千多万，每次执行都有不同的结果，这就类似于python中使用多线程后会产生资源竞争的现象 这个时候就该互斥锁上场了12345678910111213141516171819202122232425262728package mainimport ( "fmt" "sync")var wg = sync.WaitGroup&#123;&#125;var mutex = sync.Mutex&#123;&#125;func add(i *int)&#123; for k :=0;k&lt;10000000;k++&#123; mutex.Lock() *i ++ mutex.Unlock() &#125; wg.Done()&#125;func main()&#123; i := 0 go add(&amp;i) go add(&amp;i) wg.Add(2) wg.Wait() fmt.Println(i) &#125;使用互斥锁后正确计算出了结果：20000000]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Mutex</tag>
        <tag>RWMutex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go学习笔记5-channel]]></title>
    <url>%2F2019%2F01%2F04%2Fgo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-channel%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;golang中channel是一个比较重要的类型，声明关键字chan12345678package mainimport "fmt"func main()&#123; t := make(chan int, 100) t &lt;- 5 s := &lt;- t fmt.Println(s)&#125;channel 可以看作是一个管道，&lt;-是它的操作符，当&lt;-在channel右边时表示往channel里面写数据，&lt;-在左边表示从channel读取数据，声明channel时需要制定数据类型，并可以指定缓冲大小，适当的设置缓冲区大小可以提高程序的效率，因为channel在读写数据时，如果channel里面为空或者存满了，读写操作会一直阻塞。这点类似python的队列queue&emsp;&emsp;前面提到channel会存在阻塞问题，所以当使用多个channel时，可以用select 来监听1234567891011121314151617181920212223242526272829303132333435package mainimport "fmt"func main()&#123; t := make(chan int, 100) t2 := make(chan int, 100) t2 &lt;- 6 t &lt;- 5 select &#123; case c := &lt;- t: fmt.Println(c) case c2 := &lt;- t2: fmt.Println(c2) default: fmt.Println("null") &#125; select &#123; case c := &lt;- t: fmt.Println(c) case c2 := &lt;- t2: fmt.Println(c2) default: fmt.Println("null") &#125; select &#123; case c := &lt;- t: fmt.Println(c) case c2 := &lt;- t2: fmt.Println(c2) default: fmt.Println("null") &#125;&#125;输出为：56nullselect可以看作channel的switch，它会按代码顺序区判断是否有channel可以读，如果没有channel可读则走default的运算 &emsp;&emsp;select可以结合time设置阻塞超时1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "time")func main()&#123; t := make(chan int, 100) t2 := make(chan int, 100) t2 &lt;- 6 t &lt;- 5 select &#123; case c := &lt;- t: fmt.Println(c) case c2 := &lt;- t2: fmt.Println(c2) default: fmt.Println("null") &#125; select &#123; case c := &lt;- t: fmt.Println(c) case b := &lt;- time.After(time.Second *1): fmt.Println("time out") fmt.Println(b) &#125; &#125;输出：5time out2019-01-04 11:24:51.127522602 +0800 CST m=+1.002540136select 语句在没有设置default的时候，会一直阻塞到其中一个case收到消息位置，time.After()是一个单向的channel，会在延迟指定时间后发送当前时间给返回对象]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go学习笔记4]]></title>
    <url>%2F2018%2F12%2F27%2Fgo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 读文件的汉字问题 123456789101112131415161718192021package mainimport ( "bufio" "fmt" "os")func main()&#123; fp, err := os.Open("test.txt") if err != nil&#123; fmt.Println(err) &#125; //b := []byte&#123;100&#125; r := bufio.NewReader(fp) b, _ := r.ReadBytes('\n') // 以‘\n’为分隔符读取 fmt.Println(b) // 直接打印出来的是字节值[229 147 136 229 147 136] fmt.Println(string(b)) // 使用string转换类型后打印出来的是字符串哈哈，一般汉字占三个字符，刚好对应6个字节值 defer fp.Close()&#125; 字符串函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "fmt" "strings")func main1()&#123; str := "hello world" value := strings.Contains(str, "hello") if value&#123; fmt.Println(value) fmt.Println("exist") // vaule为bool值，返回是否存在 &#125;else&#123; fmt.Println(value) fmt.Println("not found") &#125;&#125;func main2()&#123; s:=[]string&#123;"hello","world"&#125; str := strings.Join(s, " ") // 以分隔符" " 拼接字符串 fmt.Println(str)&#125;func main3()&#123; str := "hello world" i := strings.Index(str, "o") // 查找str中字符串"o"是否存在，存在返回索引，不存在返回-1 fmt.Println(i)&#125;func main4 ()&#123; str := "hello!" s := strings.Repeat(str, 10) // 将字符串str重复10次 fmt.Println(s)&#125;func main5()&#123; str := "hello" s := strings.Replace(str, "l", "h", 1) // 输出为hehlo，将str中的l替换成h，从左向右开始扫描，替换一次 fmt.Println(s)&#125;func main6()&#123; str := "hello world" s := strings.Split(str, " ") // [hello world] 将字符串按分隔符" "分割，返回一个分割后的字符串切片 fmt.Println(s)&#125;func main7()&#123; str := "---hello---world---" s := strings.Trim(str, "---") //hello---world 去掉字符串前后的'---'字符串，类似于python的trip fmt.Println(s)&#125;func main()&#123; str := "hello world I am comming!" s := strings.Fields(str) // [hello world I am comming!] 返回去掉字符串中空格后，有效字符串组成的字符串切片 fmt.Println(s)&#125; 字符串类型转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( "strconv" "fmt")func main0201() &#123; //1、将其他类型转成字符串 //将bool类型转成字符串 //s:=strconv.FormatBool(false) //fmt.Println(s) //2、将整型转成字符串 //formatInt(数据，进制) 二进制 八进制 十进制 十六进 //s:=strconv.FormatInt(123,10) //s:=strconv.Itoa(123456) //fmt.Println(s) //3、浮点型转成字符串 //formatfloat(数据,'f'，保留小数位置（谁四舍五入）,位数（64 32）) s:=strconv.FormatFloat(1.155,'f',2,64) fmt.Println(s)&#125;func main0202()&#123; //1、将字符串转成bool //str:="true" ////只能将“flase”“true”转成bool类型 有多余的数据 是无效的 //b,err:=strconv.ParseBool(str) //if err!=nil&#123; // fmt.Println(err) //&#125;else &#123; // fmt.Println(b) //&#125; //2、将字符串转成整型 //str:="1234" //value,_:=strconv.ParseInt(str,10,64) //fmt.Println(value) //str:="123" //value,_:=strconv.Atoi(str) //fmt.Println(value) //3、将字符串转成浮点型 //str:="12345" // //value,_:=strconv.ParseFloat(str,64) //fmt.Println(value)&#125;func main()&#123; b:=make([]byte,0,1024) //将bool类型放在指定切片中 b=strconv.AppendBool(b,false) b=strconv.AppendInt(b,123,10) b=strconv.AppendFloat(b,1.234,'f',5,64) b=strconv.AppendQuote(b,"hello") fmt.Println(string(b))&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习笔记3]]></title>
    <url>%2F2018%2F12%2F25%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[匿名字段12345678910111213141516171819202122232425package mainimport ( "fmt")type person struct&#123; name string age int sex string&#125;type Student struct&#123; person id int score int&#125;func main()&#123; Student := Student&#123;person&#123;"张三", 100, "男"&#125;, 1, 100&#125; fmt.Println(Student) fmt.Println(Student.name) // 子结构体可以继承父结构体的字段 fmt.Println(Student.person.name)&#125; &emsp;&emsp;继承中，子结构体和父结构体如果有同名字段，采用就近原则，会优先去当前结构体的，如果没有再去取父结构体的 多重继承 1234567891011121314151617181920212223242526272829303132package mainimport "fmt"type TestA struct&#123; name string id int&#125;type TestB struct&#123; TestA sex string age int&#125;type TestC struct&#123; TestB score int&#125;func main ()&#123; var s TestC = TestC&#123;TestB&#123;TestA&#123;"ss",10&#125;,"man", 18&#125;, 4&#125; s.score=100 s.TestB.TestA.name="姆巴佩" s.name="李四" s.id=201 s.sex="男" s.age=20 s.score=10 fmt.Println(s)&#125; 多继承 12345678910111213141516171819202122package mainimport "fmt"type DemoA struct&#123; name string id int&#125;type DemoB struct&#123; age int asex string&#125;type DemoC struct&#123; DemoA DemoB score int&#125;func main ()&#123; var s DemoC = DemoC&#123;DemoA&#123;"name", 10&#125;, DemoB&#123;18, "man"&#125;, 100&#125; fmt.Println(s)&#125; 方法的定义 123456789101112131415161718package mainimport "fmt"type Int int// 方法的对象必须是本地定义的func (a Int) add (b Int, c Int) Int&#123; return a + b + c&#125;func main ()&#123; var s Int = 10 var b Int = 2 var c Int =1 s = s.add(b, c) fmt.Println(s)&#125; 方法实例 123456789101112131415161718192021222324252627282930313233343536package mainimport "fmt"type Stu struct &#123; name string age int sex string&#125;func (s *Stu) init_info(name string, age int, sex string)&#123; s.name = name s.age = age s.sex = sex&#125;func (s Stu) printInfo()&#123; fmt.Println(s)&#125;// 定义方法时，如果要修改所属对象的字段，需要将所属对象定义为指针类型，普通定义再函数退出后会被销毁，原因我也不清楚，有清楚的大佬，欢迎在评论区指正func (s *Stu) editInfo(name string, age int, sex string)&#123; s.name = name s.age = age s.sex = sex&#125;func main()&#123; var s Stu //s = new(Stu) s.init_info("sss", 18, "man") s.printInfo() s.editInfo("xxx", 20, "women") s.printInfo()&#125; 方法的继承 12345678910111213141516171819202122232425package mainimport "fmt"type Person struct&#123; id int name string age int sex string&#125;type student struct &#123; Person score int&#125;func (p *Person) sayHello()&#123; fmt.Println("我是",p.name)&#125;func main ()&#123; var s = student&#123;Person&#123;1,"sss", 28, "man"&#125;, 100&#125; fmt.Println(s) s.sayHello()&#125; &emsp;&emsp;方法的重写：直接重写一个子对象的同名方法即可实现方法重写 接口 123456789101112131415161718192021222324package mainimport "fmt"type interfaceName interface&#123; sayHello()&#125;type stu struct &#123; name string&#125;func sayHi(s interfaceName)&#123; s.sayHello()&#125;func (s stu)sayHello()&#123; fmt.Println("I am ",s.name)&#125;func main()&#123; var tmp interfaceName = stu&#123;"storm"&#125; sayHi(tmp)&#125; &emsp;&emsp;我初看接口这个知识点的时候，很疑惑，用不用接口都得实现方法，接口到底有什么用？后来看了这篇关于go语言接口的文章豁然开朗，附文章链接：“Go语言关于Interface的理解与思考” 空接口 1234567891011121314151617package mainimport "fmt"func main()&#123; // 空指针可以接受任意类型数据 var i interface &#123;&#125; i = 10 fmt.Println(i) i = "hello world" fmt.Println(i) // 空指针切片 var s []interface&#123;&#125; s = append(s, 1, "s", [3]int&#123;1,2,3&#125;, true) fmt.Println(s)&#125; 懂python的同学很容易看出来，这个空指针可以实现python的list数据结构，即list里面可以存放任意类型的数据 类型断言 12345678910111213141516package mainimport "fmt"func main()&#123; type aType interface&#123;&#125; var s aType type stru struct&#123; name string &#125; s = stru&#123;"name"&#125; value, ok := s.(aType) // 断言，data, ok := varaible.(type) data 为值，ok为bool值，type为需要断言的类型 if ok&#123;fmt.Println(value)&#125;&#125; error接口 12345678910111213141516171819202122232425package mainimport ( "errors" "fmt")func divede(a int, b int)(valur int, err error)&#123; if b == 0&#123; return 0, errors.New("除数不能为0") &#125;else &#123; return a/b, nil &#125;&#125;func main ()&#123; a := 2 b :=0 result, err := divede(a, b) if err != nil&#123; fmt.Println(err) &#125;else&#123; fmt.Println(result) &#125;&#125; panic异常 1panic("hello world2") defer延迟调用go 的 defer 语句是用来延迟执行函数的，而且延迟发生在调用函数 return 之后 1defer func()&#123;&#125;() recover 接口在别的语言一般都有异常捕获机制，比如python的try except finally,那么go语言中的异常捕获机制可以使用recover接口时间，‘recever’ 表示恢复的意思， 1234567891011121314151617181920212223242526package mainimport "fmt"func divide(a int, b int)int&#123; if b == 0&#123; panic("除数不能为0") &#125;else&#123; return a/b &#125;&#125;func main()&#123; a := 2 b := 0 defer func()&#123; err := recover() if err != nil&#123; if err == "除数不能为0"&#123; fmt.Println(err) &#125; &#125; &#125;() c := divide(a,b) fmt.Println(c)&#125; 文件创建和写入 123456789101112131415package mainimport ( "fmt" "os")func main()&#123; fp, err := os.Create("test.txt") if err != nil&#123; fmt.Println(err) &#125; fp.WriteString("哈哈") defer fp.Close()&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go学习笔记2]]></title>
    <url>%2F2018%2F12%2F25%2Fgo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 匿名函数 1234567891011121314package mainimport "fmt"func main()&#123; a:=1 b:=2 f := func(a int, b int) int &#123; fmt.Println(a,b) return a &#125; c := f(a,b) fmt.Println(c)&#125; 闭包 1234567891011121314151617package mainimport "fmt"func test1() func()int&#123; var a int return func() int &#123; a ++ return a &#125;&#125;func main()&#123; f := test1() for i:=0;i&lt;10;i++ &#123; fmt.Println(f()) &#125;&#125; 递归 12345678910111213141516package mainimport "fmt"func main()&#123; test1(10)&#125;func test1(a int)&#123; if a &lt;=0&#123; return &#125; a-- fmt.Println(a) test1(a)&#125; 随机种子 12345678910111213141516package mainimport ( "fmt" "math/rand" "time")func main()&#123; rand.Seed(time.Now().UnixNano()) for i := 0; i&lt;10; i ++&#123; x:= rand.Intn(100) fmt.Println(x) &#125;&#125; map 12345678910111213package mainimport "fmt"func main()&#123; a := make(map[int]string) a[1] = "张三" fmt.Println(a) for k,v:= range a&#123; fmt.Println(k,v) &#125; delete(a,1)&#125; 切片 123456789package mainimport "fmt"func main()&#123; a := make([]int, 5,6) a = append(a, 1,2,3,4,5,5,5,5) fmt.Println(a)&#125; 结构体 123456789101112131415161718package mainimport ( "fmt")type Student struct&#123; id int name string&#125;func main()&#123; var s Student s.id = 101 s.name = "sss" fmt.Print(s) S := Student&#123;id:103,name:"ccc"&#125; fmt.Println(S)&#125; 指针 1234567891011package mainimport "fmt"func main()&#123; var p *int // 默认值 nil，但是不会分配地址，为空指针 fmt.Println(p) p = new(int) //默认在堆区分配一个地址， 值为数据类型的默认值 fmt.Println(p) fmt.Println(*p)&#125; &emsp;&emsp; make 和new的区别，new返回的永远是一个指针，make返回的是对应的数据类型]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习笔记1]]></title>
    <url>%2F2018%2F12%2F24%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Go是一种开源的程序设计语言，它意在使得人们能够方便地构建简单、可靠、高效率的软件” hello world hello_world.py123456package mainimport "fmt"func main01() &#123; //在屏幕打印hello world fmt.Println("hello world")&#125; 变量定义&emsp;&emsp;变量定义支持显式的定义： 12345//var 变量名 数据类型var a int = 10var a int//声明变量时如果没有初始值 ，默认值为0a=10//赋值a=a+25 &emsp;&emsp;go语言中还可以动态的定义： 1PI:=3.14159 // := 可以自动判断等式右边的数据类型 &emsp;&emsp;变量还可以多重赋值 12//格式 变量1，变量2:=值1,值2a,b,c,d:=10,20,30,40 格式输出 12345678a:=123456b:=3.14159//%d 占位符 表示输出一个整型数据//%f 占位符 表示输出一个浮点型数据//\n 表示转义字符 相当于换行符fmt.Printf("==%3d==\n",a)//%f占位符默认保留六位小数 %.3f表示小数点后面保留三位小数 会对第四位四舍五入fmt.Printf("%.4f\n",b) 格式输入 123456var a intvar b stringfmt.Scanf("%3d",&amp;a)fmt.Scanf("%s",&amp;b)fmt.Println(a)fmt.Println(b) 常量&emsp;&emsp;常量的定义 1234567891011121314//常量定义和使用//在程序运行过程中其值不能发生改变的量 成为常量//常量的存储位置在数据区//栈区 系统为每一个应用程序分配1M空间用来存储变量 在程序运行结束系统会自动释放var s1 int =10var s2 int =20//常量的存储位置在数据区 不能通过&amp; 取地址来访问const a int = 10fmt.Println(&amp;s1)fmt.Println(&amp;s2)//a=20//常量的值不允许修改fmt.Println(a) go语言中的iota&emsp;&emsp;iota变量是const中一个特殊的关键字，它只能用在const的申明中，是一个从0开始的行数索引器。 123456789101112const( a=iota b=iota c=iota d=iota)fmt.Println(a)fmt.Println(b)fmt.Println(c)fmt.Println(d)// 输出结果为0，1，2，3 12345678910111213//如果定义枚举是常量写在同一行那么值相同 换一行值加一//在定义枚举时可以为其赋初始值 但是换行后不会根据值增长const( a=10 b,c=iota,iota d,e)fmt.Println(a)fmt.Println(b)fmt.Println(c)fmt.Println(d)fmt.Println(e) 输出结果为，10，1，1，2，2 算数运算&emsp;&emsp;go中算数和大多数语言一致，+，-，*， /，//，%分别表示，加减乘除，取商，取余 类型转换 1234567a:=10b:=3.99//类型转换格式 数据类型（变量） 数据类型（表达式）//c:=float64(a)*b//将浮点型转成整型数据 保留浮点型整数部分 舍弃小数部分 不会进行四舍五入c:=a*int(b)fmt.Println(c) 123456//一般将低类型转成高类型 保证数据完整性var a int32=10var b int64=20c:=int64(a)+bfmt.Println(c)fmt.Printf("%T",c) 函数定义 123456789//函数定义//func 函数名(函数参数列表)&#123;// 代码体 程序体 函数体//&#125;//变量名 数据类型 如果有多个参数中间用逗号分隔//先定义后调用func myFunc(arg1,arg2)&#123; //左花括号必须紧跟在定义语句后面，不能换行 ...&#125; 123456789101112//不定参函数 函数参数格式为 ...数据类型func test(args ...int)&#123; //fmt.Println(args) //len() 计算字符串有效长度 //len() 计算不定参函数的长度 for i:=0;i&lt;len(args);i++&#123; fmt.Println("下标 ",i,"值 ",args[i]) &#125; //fmt.Println(len(args))&#125; 1234567891011func plus(arr ...int)&#123; sum:=0 //for i:=0; i&lt;len(arr);i++ &#123; // sum+=arr[i] //&#125; //for 和range 可以遍历 集合中的数据信息，如数组 切片 结构体数组 map for _,data:=range arr&#123; sum+=data &#125; fmt.Println(sum)&#125; 12345678910//func 函数名（形参列表）返回值类型列表&#123;代码体&#125;func sub(a int ,b int ) int &#123; sum:=a-b //return 表示函数的结束 return 后面的代码不会执行 同时return也会将函数的返回值传递给主调函数 return sum fmt.Println("helloworld") fmt.Println("helloworld") fmt.Println("helloworld") return 0&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport "fmt"func test6()&#123; fmt.Println("瓜娃子")&#125;func test7(a int, b int)&#123; fmt.Println(a+b)&#125;func test9(a int, b int) int&#123; return a+b&#125;func test8() &#123; fmt.Println("细伢子")&#125;//type 可以定义函数类型//type 可以为已存在类型起别名type FUNCTYPE func()type FUNCTEST func(int,int)type funcdemo func(int,int)intfunc main1101() &#123; //定义函数类型变量 var f FUNCTYPE f=test6 //通过函数变量调用函数 f() //f=test7//err函数类型不一致 //f() f=test8 f() //函数类型 其实就是一个指针 var f1 FUNCTEST f1=test7 f1(10,20) var f2 funcdemo f2=test9 v:=f2(10,20) fmt.Println(v)&#125;func test10(a int, b int)&#123; fmt.Println(a+b)&#125;func main()&#123; //函数调用 //test10(10,20) //如果使用Print打印函数名是一个地址 //函数名本身就是一个指针类型数据 在内存中代码区进行存储 //fmt.Println(test10) //自动类型推到创建函数类型 //f:=test10 //f(10,20) //fmt.Printf("%T",f) //直接定义函数类型 var f func(int,int) f=test10 f(10,20)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport "fmt"func main1201() &#123; //demo1() //局部变量 在函数内部定义的变量 作用域限定于本函数内部 从变量定义到本函数结束有效 //var 变量名 数据类型 先定义后使用 //在同一作用域范围内 变量名是唯一的 //fmt.Printf(a) //a:=10 ////匿名内部函数 //&#123; // //var a int =20 // a:=20 // fmt.Println(a) //&#125; //fmt.Println(a) //程序中如果出现了相同的变量名 如果本函数有自己的变量 就使用自己的 如果没有上外层寻找变量 //如果名字相同会采用就进原则 使用自己的变量 i:=0//i:=0 for i:=0;i&lt;10;i++&#123; &#125; fmt.Println(i)&#125;//func demo1()&#123;// fmt.Println(a)//&#125;func main()&#123; demo2() //采用就进原则使用局部变量 //在局部变量作用域范围内 全局变量不起作用 a:=234 fmt.Println(a)&#125;//全局变量 在函数外部定义的变量成为全局变量//全局变量作用域是项目中所有文件//全局变量在内存中数据区存储 和const定义的常量存储位置都是数据区var a int=10//如果全局变量没有初始值值为0//全局常量const b int =10func demo2()&#123; a=123 //const a int =10 fmt.Println(a)&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python和c混合编程-cython]]></title>
    <url>%2F2018%2F12%2F21%2Fpython%E5%92%8Cc%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-cython%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Cython,官方在首页标题就给出了解释，C-Extensions for Python,即python的c扩展。它是一种可以像写python一样轻松地为python语言编写c扩展程序的编程语言，话不多说，用代码解释，哈哈 安装cython 安装cython1pip install Cython cython 的hello world 创建一个文件，“hello.pyx”,写入代码 cython hello world1234567def say_hello(): print("hello world!")def test_c_define(): cdef int a = 0 for i in range(10): a += i print(a) 创建文件“setup.py”,写入代码： setup.py12345from distutils.core import setupfrom Cython.Build import cythonizesetup(name='Hello world app', ext_modules=cythonize("hello.pyx")) 编译： 1python setup.py build_ext --inplace 编译成功后，目录下会多处两个文件,hello.c、hello.so,现在进入ipython后可以直接倒入hello模块了 &emsp;&emsp;如果觉得手动编译很麻烦，还可以在程序内部导入pyximport模块，具体使用如下：12345678910111213In [1]: import pyximport; pyximport.install()Out[1]: (None, &lt;pyximport.pyximport.PyxImporter at 0x111307450&gt;)In [2]: import hello/Users/storm/.virtualenvs/py2cpython/lib/python2.7/site-packages/Cython/Compiler/Main.py:367: FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2). This will change in a later release! File: /Users/storm/Desktop/cpython_test/hello.pyx tree = Parsing.p_module(s, pxd, full_module_name)In [3]: hello.say_hello()hello world!In [4]: hello.test_c_define()45更多cython语法可以参考官方文档]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求头中的反反爬]]></title>
    <url>%2F2018%2F12%2F19%2F%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%8F%8D%E7%88%AC%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;有关请求头反爬的总结，其实大多时候这些反爬并不是官方刻意做的反爬，而是人家的业务逻辑就是如此。&nbsp;&nbsp;&nbsp;&nbsp;在我工作中很多时候就是由于请求头设置不对导致请求不到数据，通常会报网络异常、服务端的代码报错、登录失效等 Content-Type: text/plain格式请求抓包: Content-Type: text/plain格式请求抓包123456789101112131415161718192021222324POST url HTTP/1.1Accept: */*Accept-Language: zh-cnReferer: referer_urlContent-Type: text/plainAccept-Encoding: gzip, deflateUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)Host: hostContent-Length: 341Connection: Keep-AliveCache-Control: no-cacheCookie: JSESSIONID=vNm_8OTVmsEKMruINvDKc9Va0U0wSRtXX01h-MUOb20isl025ONy!1695113430; chinainsuranceSimpleJSESSIONID=FvTTcYPRh2Vqy16FpZmsCJlsJ6whByyynvhKzd8YY1JBhLH1J6JS!-1750044110; BIGipServerPOOL_WG_WG=201657354.16927.0000; chinainsuranceJSESSIONID=vDp6cYPFRKYGT81gsmkJ152DSMQP0NsJYq6BcN1NnCJXM0QQLVLd!1400829094; BIGipServerPOOL_WG_CORE=218434570.17183.0000callCount=1page=。。。。。。httpSessionId=scriptSessionId=00641BE009C679C16CED73F72ACF6AC9848c0-scriptName=dwrInvokeDataActionc0-methodName=checkNewProductIndc0-id=0c0-e1=string:0383130205c0-e2=string:0801c0-param0=Array:[reference:c0-e1,reference:c0-e2]batchId=3 Content-Type: application/x-www-form-urlencoded格式请求抓包 Content-Type: application/x-www-form-urlencoded格式请求抓包1234567891011121314POST url HTTP/1.1Accept: image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, application/x-ms-xbap, */*Referer: referer_urlAccept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)Content-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: hostContent-Length: 169Connection: Keep-AliveCache-Control: no-cacheCookie: JSESSIONID=vNm_8OTVmsEKMruINvDKc9Va0U0wSRtXX01h-MUOb20isl025ONy!1695113430; chinainsuranceSimpleJSESSIONID=FvTTcYPRh2Vqy16FpZmsCJlsJ6whByyynvhKzd8YY1JBhLH1J6JS!-1750044110; BIGipServerPOOL_WG_WG=201657354.16927.0000; chinainsuranceJSESSIONID=vDp6cYPFRKYGT81gsmkJ152DSMQP0NsJYq6BcN1NnCJXM0QQLVLd!1400829094; BIGipServerPOOL_WG_CORE=218434570.17183.0000dsMakingFlag=1&amp;proposaladd=new&amp;risk=0801&amp;applySelect=&amp;relationNo=&amp;applyNo=&amp;applySerialNo.......... &nbsp;&nbsp;&nbsp;&nbsp;Content-Type这个字段表示整个请求体的内容类型，很多时候的网络异常就是这个字段导致的&nbsp;&nbsp;Cookie 不用多少，用来让服务器识别你的一些身份信息的，需要额外补充的是，当某些时候明明其他请求头和请求体设置正确却拿不到正确响应的时候可以看一下，是否在这个请求之前少了其他请求，具体可以用fiddler抓包浏览器的请求,看之前有没有请求在本地存储cookie如果有设置cookie，在代码中加上那个请求，获取到cookie，在cookie和浏览器的cookie一致后一般都能解决问题&nbsp;&nbsp;Referer大多时候不传也能获取到响应，但偶尔也有少数请求需要带上才能正常访问&nbsp;&nbsp;在text/plain类型的请求中，参数scriptSessionId我起初没有注意，直接乱写的一串字符，到之后续的请求报错，经排查后发现，这个字段估计是一个服务端的session相关字段，往往相邻几个请求都需要用这同一个id才能拿到响应，当时我是前后两个请求用了不同sessionid &nbsp;&nbsp;&nbsp;&nbsp;另外，爬虫爬不到数据，或爬到错误数据，超过70%的原因都是请求体中数据传的不对，我维护的项目里，几个关键请求的参数都有2000多个，所以我的工作基本就是在找错误字段[手动苦笑],但是从这个脏活中我也总结出拿不到正确响应的几点规律： 部分字段对应的值传的不对，比如某些flag字段应该传1的我传了0， 部分字段名有时候需要重复，例如这种：这种情况，重复次数不一致，或后面的值不对也会导致请求失败 有时候浏览器发的请求，请求体字段是有先后顺序，而我们的代码中有时候经过一段时间的维护改动后，爬虫发出的请求体字段顺序和浏览器发的字段顺序不一致了，这时候就有可能导致请求失败，这种一般都是在前面两种问题完全排除了后，才考虑第三种可能，因为一上来就手动给两千多个参数排顺序实在有点累]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>反反爬</tag>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证码识别的总结]]></title>
    <url>%2F2018%2F12%2F18%2F%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我目前工作中对接的目标网站都采用的大多是文本识别类型的验证码，类似于这种 还有微信二维码动态获取的 前两种验证码可以使用像素点比对的方式，将样本图片切割成单个字符的图片，然后灰度话，二值化，去噪点，可以得到白底黑字的样本，使用python科学计算库numpy将图片转换成一个0和1组成的矩阵np.array(img)，最后可以把每个字符样本以（识别值：矩阵值）的形式保存到一个python文件中，训练出大量的样本数据保存为矩阵值，识别的时候将需要识别的图片切割，按同样的方式转化成矩阵值，然后和样本库一一比对sum(imap(lambda x, y: bin(x ^ y).count(‘1’), l1, l2))，差异最少的那个矩阵对应的值作为识别值，这种识别方式比较简单粗暴，所以就不贴详细过程了。 第三种中文识别一开始我还是采用的上面那种方式识别，效果也不错，不过就是存在一些问题，容易把两个形状相近的字体搞错，比如把陆和除，叁和乘，加和四搞反，但也基本满足生产需求，平均正确率70%，为了提高正确率，我找到了神经网络来训练的方法，卷积神经网络，先后尝试了k近邻算法。使用谷歌的tensorflow框架就可以搭建卷积网络模型 cnn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324#coding=utf-8import os#图像读取库from PIL import Imagefrom PIL import ImageEnhancefrom PIL import ImageFilter#矩阵运算库import numpy as npimport tensorflow as tf# 数据文件夹data_dir = "data"test_data_dir = "test_data"# 训练还是测试train = True# 模型文件路径model_path = "model/image_model"char_to_digit = ["零","壹","贰","叁","肆","伍","陆","柒","捌","玖","拾","一","二","三","四","五","六","七","八","九","加","减","乘","除"]def max_dif(x, y, z): '''计算三个值之间最大的差值''' max = min = x if y &gt; max: max = y else: min = y if z &gt; max: max = z else: min = z return max - mindef binar_by_rgb(img): '''根据rgb二值化''' w, h = img.size for y in range(h): for x in range(w): r, g, b = img.getpixel((x, y)) a_list = sorted([r, g, b]) diff = max_dif(r, g, b) # if diff &lt; 16 and a_list[2]&lt;128: # img.putpixel((x,y),(255,255,255)) if diff &lt; 16 and a_list[0] &gt; 128 and a_list[2] &lt; 255: img.putpixel((x, y), (0, 0, 0)) # if diff &gt;32 and a_list[0] &gt;224 : # img.putpixel((x, y), (0, 0, 0)) # else: # img.putpixel((x, y), (0, 0, 0)) # print_img(self.img) # import pdb # pdb.set_trace() return imgdef graying(img): u"""灰度化.""" img = img.convert("L") return imgdef remove_boader(img): """去除边框上的噪点""" w, h = img.size for x in range(w): img.putpixel((x, 0), 255) img.putpixel((x, 1), 255) img.putpixel((x, h-1), 255) img.putpixel((x, h-2), 255) for y in range(h): img.putpixel((0, y), 255) img.putpixel((1, y), 255) img.putpixel((w-1, y), 255) img.putpixel((w - 2, y), 255) return imgdef filter_line(img, v): """分解斜线为孤点""" w, h = img.size black_point = 1 white_point = 0 for x in range(v, w - v): for y in range(v, h - v): mid_pixel = img.getpixel((x, y)) # 中央像素点像素值 if mid_pixel == 0: # 找出上下左右右下五个像素点像素值 top_pixel = img.getpixel((x, y-v)) left_pixel = img.getpixel((x-v, y)) down_pixel = img.getpixel((x, y+v)) right_pixel = img.getpixel((x+v, y)) right_down_pixel = img.getpixel((x+v, y+v)) right_top_pixel = img.getpixel((x + v, y - v)) left_down_pixel = img.getpixel((x - 1, y + 1)) left_top_pixel = img.getpixel((x - 1, y - 1)) # 如果一个点周围九宫格内只有 if top_pixel == 255: # 上 white_point += 1 if left_pixel == 255: # 左 white_point += 1 if down_pixel == 255: # 下 white_point += 1 if right_pixel == 255: # 右 white_point += 1 if right_down_pixel == 0: # 右下 black_point += 1 elif right_top_pixel == 0: # 右上 black_point += 1 elif left_down_pixel == 0: # 左下 black_point += 1 elif left_top_pixel == 0: # 左上 black_point += 1 if black_point &gt;= 2 and white_point &gt;= 3: img.putpixel((x, y), 255) # print black_point black_point = 1 white_point = 0 return imgdef filter_line_pro(img, v): """去除孤点""" w, h = img.size black_point = 1 for x in range(v, w - v): for y in range(v, h - v): mid_pixel = img.getpixel((x, y)) # 中央像素点像素值 if mid_pixel == 0: # 找出上下左右四个方向像素点像素值 top_pixel = img.getpixel((x, y - v)) left_pixel = img.getpixel((x - v, y)) down_pixel = img.getpixel((x, y + v)) right_pixel = img.getpixel((x + v, y)) right_down_pixel = img.getpixel((x + v, y + v)) right_top_pixel = img.getpixel((x+v, y-v)) left_down_pixel = img.getpixel((x-1, y+1)) left_top_pixel = img.getpixel((x-1, y-1)) # 判断上下左右的黑色像素点总个数 if top_pixel == 0: black_point += 1 if left_pixel == 0: black_point += 1 if down_pixel == 0: black_point += 1 if right_pixel == 0: black_point += 1 if right_down_pixel == 0: black_point += 1 if right_top_pixel == 0: black_point += 1 if left_down_pixel == 0: black_point += 1 if left_top_pixel == 0: black_point += 1 if black_point &lt;= 2: # 以x，y为中心的九个像素点中黑色像素点个数为1 or 2,这种情况认为该点为噪点 img.putpixel((x, y), 255) # print black_point black_point = 1 return imgdef binarization(img): u"""二值化, 白底黑字.""" w, h = img.size for y in range(h): for x in range(w): color = img.getpixel((x, y)) if color &gt;= 224: img.putpixel((x, y), 255) else: img.putpixel((x, y), 0) # print_img(img) # import pdb # print_img(img) # pdb.set_trace() img = remove_boader(img) # print_img(img) # pdb.set_trace() img = filter_line(img, 1) # print_img(img) # pdb.set_trace() img = filter_line_pro(img, 1) return img# 从文件夹读取图片和标签到numpy数组中# 标签信息在文件名中，将标签（文件名第一个字符映射为一个数字），存到标签数组def read_data(data_dir): datas = [] labels = [] fpaths = [] for fname in os.listdir(data_dir): if fname.split("_")[0] not in char_to_digit: continue # 非法标签，去掉 fpath = os.path.join(data_dir, fname) fpaths.append(fpath) image = Image.open(fpath) image = ImageEnhance.Contrast(image).enhance(2.0) image = image.filter(ImageFilter.EDGE_ENHANCE_MORE) image = binar_by_rgb(image) image = graying(image) image = binarization(image) image.save("data/preprocessed_data/&#123;&#125;".format(fname)) data = np.array(image) # data = np.array(image) / 255.0 # data = np.array(image.convert("L")) / 255.0 label = int(char_to_digit.index(fname.split("_")[0])) datas.append(data.reshape(30, 26, 1)) # datas.append(data) labels.append(label) datas = np.array(datas) labels = np.array(labels) print("shape of datas: &#123;&#125;\tshape of labels: &#123;&#125;".format(datas.shape, labels.shape)) return fpaths, datas, labelsfpaths, datas, labels = read_data(data_dir)test_fpath, test_datas, test_labels = read_data(test_data_dir)data_len = datas.shape[0]# 计算有多少类图片num_classes = len(set(labels))# 定义Placeholder，存放输入和标签 图片样本大小为26*30*1# datas_placeholder = tf.placeholder(tf.float32, [None, 30, 26, 1])datas_placeholder = tf.placeholder(tf.float32, [None, 30, 26, 1])labels_placeholder = tf.placeholder(tf.int32, [None])# 存放DropOut参数的容器，训练时为0.25，测试时为0dropout_placeholdr = tf.placeholder(tf.float32)# 定义卷积层, 25个卷积核, 卷积核大小为1，用Relu激活conv0 = tf.layers.conv2d(datas_placeholder, 25, 1, activation=tf.nn.relu)# 定义max-pooling层，pooling窗口为2x2，步长为2x2pool0 = tf.layers.max_pooling2d(conv0, [2, 2], [2, 2])# 定义卷积层, 40个卷积核, 卷积核大小为1，用Relu激活conv1 = tf.layers.conv2d(conv0, 40, 1, activation=tf.nn.relu)# 定义max-pooling层，pooling窗口为2x2，步长为2x2pool1 = tf.layers.max_pooling2d(conv1, [2, 2], [2, 2])# 将3维特征转换为1维向量flatten = tf.layers.flatten(conv1)# 全连接层，转换为长度为100的特征向量fc = tf.layers.dense(flatten, 100, activation=tf.nn.relu)# 加上DropOut，防止过拟合dropout_fc = tf.layers.dropout(fc, dropout_placeholdr)# 未激活的输出层logits = tf.layers.dense(dropout_fc, num_classes)# logits = tf.layers.dense(fc, num_classes)predicted_labels = tf.argmax(logits, 1)# 利用交叉熵定义损失losses = tf.nn.softmax_cross_entropy_with_logits( labels=tf.one_hot(labels_placeholder, num_classes), logits=logits)# 平均损失mean_loss = tf.reduce_mean(losses)# 定义优化器，指定要优化的损失函数optimizer = tf.train.AdamOptimizer(learning_rate=1e-2).minimize(losses)# 用于保存和载入模型saver = tf.train.Saver()with tf.Session() as sess: if train: print("训练模式") # 如果是训练，初始化参数 sess.run(tf.global_variables_initializer()) # 定义输入和Label以填充容器，训练时dropout为0.25 train_feed_dict = &#123; datas_placeholder: datas, labels_placeholder: labels, dropout_placeholdr: 0.25 &#125; for step in range(150): _, mean_loss_val = sess.run([optimizer, mean_loss], feed_dict=train_feed_dict) if step % 10 == 0: print("step = &#123;&#125;\tmean loss = &#123;&#125;".format(step, mean_loss_val)) saver.save(sess, model_path) print("训练结束，保存模型到&#123;&#125;".format(model_path)) else: print("测试模式") # 如果是测试，载入参数 saver.restore(sess, model_path) print("从&#123;&#125;载入模型".format(model_path)) label_name_dict = &#123;k: v for k,v in enumerate(char_to_digit)&#125; # 定义输入和Label以填充容器，测试时dropout为0 test_feed_dict = &#123; datas_placeholder: test_datas, labels_placeholder: test_labels, dropout_placeholdr: 0 &#125; predicted_labels_val = sess.run(predicted_labels, feed_dict=test_feed_dict) # 真实label与模型预测label err_count = 0 err_pred = [] for fpath, real_label, predicted_label in zip(test_fpath, test_labels, predicted_labels_val): # 将label id转换为label名 real_label_name = label_name_dict[real_label] predicted_label_name = label_name_dict[predicted_label] if real_label_name != predicted_label_name: err_count += 1 err_pred.append((real_label_name,predicted_label_name)) print("&#123;&#125;\t&#123;&#125; =&gt; &#123;&#125;".format(fpath, real_label_name, predicted_label_name)) print(err_count) print(err_pred) k近邻也是用tensorflow实现的knn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271import numpy as npimport tensorflow as tfimport tensorflow.examples.tutorials.mnist.input_data as input_dataimport os#图像读取库from PIL import Imagefrom PIL import ImageEnhancefrom PIL import ImageFilter#矩阵运算库import numpy as npimport tensorflow as tf# 数据文件夹data_dir = "data"test_data_dir = "test_data"# 训练还是测试train = True# 模型文件路径model_path = "model/image_model"char_to_digit = ["零","壹","贰","叁","肆","伍","陆","柒","捌","玖","拾","一","二","三","四","五","六","七","八","九","加","减","乘","除"]def max_dif(x, y, z): '''计算三个值之间最大的差值''' max = min = x if y &gt; max: max = y else: min = y if z &gt; max: max = z else: min = z return max - mindef binar_by_rgb(img): '''根据rgb二值化''' w, h = img.size for y in range(h): for x in range(w): r, g, b = img.getpixel((x, y)) a_list = sorted([r, g, b]) diff = max_dif(r, g, b) # if diff &lt; 16 and a_list[2]&lt;128: # img.putpixel((x,y),(255,255,255)) if diff &lt; 16 and a_list[0] &gt; 128 and a_list[2] &lt; 255: img.putpixel((x, y), (0, 0, 0)) # if diff &gt;32 and a_list[0] &gt;224 : # img.putpixel((x, y), (0, 0, 0)) # else: # img.putpixel((x, y), (0, 0, 0)) # print_img(self.img) # import pdb # pdb.set_trace() return imgdef graying(img): u"""灰度化.""" img = img.convert("L") return imgdef remove_boader(img): """去除边框上的噪点""" w, h = img.size for x in range(w): img.putpixel((x, 0), 255) img.putpixel((x, 1), 255) img.putpixel((x, h-1), 255) img.putpixel((x, h-2), 255) for y in range(h): img.putpixel((0, y), 255) img.putpixel((1, y), 255) img.putpixel((w-1, y), 255) img.putpixel((w - 2, y), 255) return imgdef filter_line(img, v): """分解斜线为孤点""" w, h = img.size black_point = 1 white_point = 0 for x in range(v, w - v): for y in range(v, h - v): mid_pixel = img.getpixel((x, y)) # 中央像素点像素值 if mid_pixel == 0: # 找出上下左右右下五个像素点像素值 top_pixel = img.getpixel((x, y-v)) left_pixel = img.getpixel((x-v, y)) down_pixel = img.getpixel((x, y+v)) right_pixel = img.getpixel((x+v, y)) right_down_pixel = img.getpixel((x+v, y+v)) right_top_pixel = img.getpixel((x + v, y - v)) left_down_pixel = img.getpixel((x - 1, y + 1)) left_top_pixel = img.getpixel((x - 1, y - 1)) # 如果一个点周围九宫格内只有 if top_pixel == 255: # 上 white_point += 1 if left_pixel == 255: # 左 white_point += 1 if down_pixel == 255: # 下 white_point += 1 if right_pixel == 255: # 右 white_point += 1 if right_down_pixel == 0: # 右下 black_point += 1 elif right_top_pixel == 0: # 右上 black_point += 1 elif left_down_pixel == 0: # 左下 black_point += 1 elif left_top_pixel == 0: # 左上 black_point += 1 if black_point &gt;= 2 and white_point &gt;= 3: img.putpixel((x, y), 255) # print black_point black_point = 1 white_point = 0 return imgdef filter_line_pro(img, v): """去除孤点""" w, h = img.size black_point = 1 for x in range(v, w - v): for y in range(v, h - v): mid_pixel = img.getpixel((x, y)) # 中央像素点像素值 if mid_pixel == 0: # 找出上下左右四个方向像素点像素值 top_pixel = img.getpixel((x, y - v)) left_pixel = img.getpixel((x - v, y)) down_pixel = img.getpixel((x, y + v)) right_pixel = img.getpixel((x + v, y)) right_down_pixel = img.getpixel((x + v, y + v)) right_top_pixel = img.getpixel((x+v, y-v)) left_down_pixel = img.getpixel((x-1, y+1)) left_top_pixel = img.getpixel((x-1, y-1)) # 判断上下左右的黑色像素点总个数 if top_pixel == 0: black_point += 1 if left_pixel == 0: black_point += 1 if down_pixel == 0: black_point += 1 if right_pixel == 0: black_point += 1 if right_down_pixel == 0: black_point += 1 if right_top_pixel == 0: black_point += 1 if left_down_pixel == 0: black_point += 1 if left_top_pixel == 0: black_point += 1 if black_point &lt;= 2: # 以x，y为中心的九个像素点中黑色像素点个数为1 or 2,这种情况认为该点为噪点 img.putpixel((x, y), 255) # print black_point black_point = 1 return imgdef binarization(img): u"""二值化, 白底黑字.""" w, h = img.size for y in range(h): for x in range(w): color = img.getpixel((x, y)) if color &gt;= 224: img.putpixel((x, y), 255) else: img.putpixel((x, y), 0) # print_img(img) # import pdb # print_img(img) # pdb.set_trace() img = remove_boader(img) # print_img(img) # pdb.set_trace() img = filter_line(img, 1) # print_img(img) # pdb.set_trace() img = filter_line_pro(img, 1) # print_img(img) # pdb.set_trace() # img = self.filter_line(img, 1) # img = self.filter_line_pro(img,1) # img = self.filter_line(img,1) # self.pIx(img) # print_img(img) # pdb.set_trace() return img# 从文件夹读取图片和标签到numpy数组中# 标签信息在文件名中，将标签（文件名第一个字符映射为一个数字），存到标签数组def read_data(data_dir): datas = [] labels = [] fpaths = [] for fname in os.listdir(data_dir): if fname.split("_")[0] not in char_to_digit: continue # 非法标签，去掉 fpath = os.path.join(data_dir, fname) fpaths.append(fpath) image = Image.open(fpath) image = ImageEnhance.Contrast(image).enhance(2.0) image = image.filter(ImageFilter.EDGE_ENHANCE_MORE) image = binar_by_rgb(image) image = graying(image) image = binarization(image) image.save("data/preprocessed_data/&#123;&#125;".format(fname)) data = np.array(image) # data = np.array(image) / 255.0 # data = np.array(image.convert("L")) / 255.0 label = int(char_to_digit.index(fname.split("_")[0])) datas.append(data.flatten()) # datas.append(data) tmp1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] tmp1[label] = 1 labels.append(tmp1) datas = np.array(datas) labels = np.array(labels) print("shape of datas: &#123;&#125;\tshape of labels: &#123;&#125;".format(datas.shape, labels.shape)) return fpaths, datas, labelsfpaths,train_X, train_Y = read_data(data_dir)test_fpath, test_X, test_Y = read_data(test_data_dir)import pdbpdb.set_trace()tra_X = tf.placeholder("float", [None, 780])te_X = tf.placeholder("float", [780])# 使用L1计算近邻距离distance = tf.reduce_sum(tf.abs(tf.add(tra_X, tf.negative(te_X))), reduction_indices=1)# 预测：获取最近的样本点的索引pred = tf.arg_min(distance, 0)accuracy = 0.# 初始化变量init = tf.initialize_all_variables()# 开启会话with tf.Session() as sess: sess.run(init) # 测试数据的循环 for i in range(len(test_X)): # 获取最近邻居 nn_index = sess.run(pred, feed_dict=&#123;tra_X: train_X, te_X: test_X[i, :]&#125;) # 获取最近邻样本的标签，并与真实样本标签进行比较 print("Test", i, "Prediction:", np.argmax(train_Y[nn_index]), \ "True Class:", np.argmax(test_Y[i])) # 计算准确率 if np.argmax(train_Y[nn_index]) == np.argmax(test_Y[i]): accuracy += 1. / len(test_X) print("Done!") print("Accuracy:", accuracy) 使用cnn和knn后，测试集正确率均能达90%以上 第四种二维码的验证方式看着复杂，实则是最简单的，通过fiddler抓包手机扫描二维码后的请求，发现每一个账号都有其固定不变的一个值，在识别的时候带着那个值模拟请求一次对方的动态验证码接口，就可以拿到验证码]]></content>
      <categories>
        <category>爬虫</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>反反爬</tag>
        <tag>卷积神经网络</tag>
        <tag>k近邻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2F2018%2F12%2F13%2F%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[终于弄好了hello world1print("hello world")]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
